<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>AuthorScript&#174; Advanced Data 3.2 SDK Guide - Chapter 7</TITLE>
<!-- AuthorScript Advanced Data SDK version 3.2 -->
<!-- HTML version generated by DelPhi on 060707 -->
<!-- (c) 2002-2007 Sonic Solutions. All Rights Reserved. -->
<LINK REL=STYLESHEET TYPE="text/css" HREF="AD_Styles-MAIN.css">
</HEAD>

<BODY>
<TABLE WIDTH="100%" ALIGN=center BORDER=0><TBODY>
<TR><TD WIDTH=520><A ID="chapter"><IMG SRC="AD_Images/AD_Banner.jpg" WIDTH=520 HEIGHT=71></A>
<TR><TD WIDTH=520 HEIGHT=52 ALIGN=right VALIGN=top><P CLASS="IndentSans" ALIGN="Right">&#169; 2002-2007 Sonic Solutions<SUP>&#153;</SUP>. All Rights Reserved.</P></TD><TD></TD></TR></TBODY></TABLE>
<P CLASS="Heading1"><A ID="Volumes and Files">7 &nbsp;Volumes and Files</A></P>
<P CLASS="IndentSerif">This chapter describes AuthorScript Advanced Data functions related to volumes and files. These functions are covered in the following sections:</P>
<UL CLASS="IndentSerif_List"><LI><A HREF="#Volume Management">Volume Management</A></LI>
<LI><A HREF="#Directory and File Creation">Directory and File Creation</A></LI>
<LI><A HREF="#Directory and File Information">Directory and File Information</A></LI>
<LI><A HREF="#File Read and Write">File Read and Write</A></LI></UL>
<P CLASS="IndentSerif">To find a specific call by name, see <A HREF="AD_Guide_4.htm">Chapter 4</A>, <SPAN CLASS="Arial_Inline"><B>Function Index</B></SPAN>.<BR>
<BR>
Each function entry below includes a description of the usage of the function, a list of values typically returned when the function is called, and the function&#39;s parameter(s). Each parameter is designated as one of the following:<BR>
-  <SPAN CLASS="Courier_New_Inline"><I>[IN]</I> </SPAN>the value is passed into the function from the object; the object is not modified by the call.<BR>
- <SPAN CLASS="Courier_New_Inline"><I>[IN&#47;OUT]</I> </SPAN>the value is passed into the function from the object; the object may subsequently be modified by the call.<BR>
- <SPAN CLASS="Courier_New_Inline"><I>[OUT]</I> </SPAN>the value of the object is filled in by the function.<BR>
<BR>
<B><FONT COLOR="ff0000">!</FONT> NOTE</B>: This document discusses the functionality of all calls that are part of the overall AuthorScript AD SDK version for which this documentation has been provided. The availability of a particular call to a given AuthorScript AD licensee, however, depends on the specifics of the license. Please contact Sonic if you have any questions about which calls are covered in your AuthorScript AD license.</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Volume Management">7.1 &nbsp;Volume Management</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section covers the following calls:</P>

<P CLASS="LinksList"><A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>, <A HREF="#AS_Volume_Close">AS_Volume_Close</A>, <A HREF="#AS_Volume_Mount">AS_Volume_Mount</A>, <A HREF="#AS_Volume_Create">AS_Volume_Create</A>, <A HREF="#AS_Volume_Prepare">AS_Volume_Prepare</A>, <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A>, <A HREF="#AS_Volume_SetBootable">AS_Volume_SetBootable</A>, <A HREF="#AS_Volume_GetProperty">AS_Volume_GetProperty</A>, <A HREF="#AS_Volume_SetProperty">AS_Volume_SetProperty</A></P>
<P CLASS="IndentSerif">These calls are used to make a volume available to AuthorScript AD, to deal with volume-level operations, and to release a volume when it is no longer needed.<BR>
<BR>
<B>NOTE</B>: The device containing the target volume should be reserved (see <A HREF="AD_Guide_6.htm#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using any of the functions in this section.</P>

<P CLASS="SubHead_Sans12"><A ID="Volume call sequence">Volume call sequence</A></P>
<P CLASS="IndentSerif">The steps involved in setting up to access and modify a volume would typically be as follows:</P>
<OL CLASS="IndentSerif_NumList"><LI>If the device containing the disc that is to be the target of the volume operations is not already open, begin with <A HREF="AD_Guide_6.htm#AS_OpenStorageDevice">AS_OpenStorageDevice</A> (see also <A HREF="AD_Guide_6.htm#Device call sequence"><SPAN CLASS="Arial_Inline"><B>Device call sequence</B></SPAN></A>).</LI>
<LI><A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A> creates a data structure in RAM that is ready to receive file structure information from the disc in the specified device.</LI>
<LI>To work with the disc&#39;s existing content, use <A HREF="#AS_Volume_Mount">AS_Volume_Mount</A> to populate the data structure in RAM with the actual file system data from the disc. Alternatively, if the disc is blank or its existing contents are going to be ignored (on recordable media) or overwritten (on rewritable media), use <A HREF="#AS_Volume_Create">AS_Volume_Create</A> to format the volume to the desired file system.</LI>
<LI>If desired, make the volume bootable by adding a boot file with <A HREF="#AS_Volume_SetBootable">AS_Volume_SetBootable</A>.</LI>
<LI>Once the volume is mounted, the structure in RAM may be modified (add&#47;delete files, folders, etc.) with the calls in <A HREF="#Directory and File Creation"><SPAN CLASS="Arial_Inline"><B>Directory and File Creation</B></SPAN></A> below. <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A> writes these changes back to the file system on the actual disc.</LI>
<LI>When work on the volume is completed, <A HREF="#AS_Volume_Close">AS_Volume_Close</A> closes the volume, and <A HREF="AD_Guide_6.htm#AS_StorageDevice_Close">AS_StorageDevice_Close</A> closes the session for the device containing the volume.</LI></OL>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_OpenVolume opens a volume, creating a data structure in RAM that is ready to receive file structure information from the media in the specified device. The volume&#39;s logical format (see <A HREF="AD_Guide_5.htm#File system type">File system type</A>) is output with the parameter <I>kind</I> (if the media is blank its type will be <SPAN CLASS="Courier_New_Inline">FS_None = 0</SPAN>). A reference for the volume is output with <I>volume</I>, and may be used to refer to the volume in subsequent calls.<BR>
<BR>
A callback with which the AuthorScript engine will report on the progress of the operation is specified with <I>callback</I>. The parameter <I>userdata</I> allows the host application to specify a pointer to a memory location that will be passed back whenever AuthorScript calls the callback.<BR>
<BR>
<B>NOTES: <BR>
&#187; </B>An error (<SPAN CLASS="Courier_New_Inline">AS_StorageError_NotSupported</SPAN>) will result if the format of the volume is not supported by your version of AuthorScript AD. Please contact your Sonic representative if you have any questions about which formats are covered.<BR>
<B>&#187;</B> An error (<SPAN CLASS="Courier_New_Inline">AS_StorageError_NotSupported</SPAN>) will result if the volume contains any sectors in Data Mode 2 format.<B><BR>
&#187;</B> Once opened, a volume may be mounted with <A HREF="#AS_Volume_Mount">AS_Volume_Mount</A> or formatted with <A HREF="#AS_Volume_Create">AS_Volume_Create</A>. <B><BR>
&#187; </B>AuthorScript AD does not currently support reading from or writing to CD-Audio, VCD, or SVCD volumes. However, AuthorScript AD does open CD-R&#47;RW media that is formatted in these file system types to allow reformatting to a different file system (with AS_Volume_Create).<BR>
<B>&#187;</B> For further information on working with devices, see <A HREF="AD_Guide_6.htm#Device call sequence"><SPAN CLASS="Arial_Inline"><B>Device call sequence</B></SPAN></A>.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_OpenVolume(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;AS_Volume::FS_Type & kind,<BR>
&nbsp;&nbsp;AS_Volume::InfoCallback callback,<BR>
&nbsp;&nbsp;void * userdata,<BR>
&nbsp;&nbsp;AS_Volume & volume<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device containing the volume to open.</P>

<P CLASS="Code_Ital">kind [OUT]</P>
<P CLASS="Def_Field">A reference to the AS_Volume::FS_Type object that is to be filled in with a <A HREF="AD_Guide_5.htm#File system type">File system type</A> constant indicating the kind of volume detected.</P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Volume information callback">Volume information callback</A> (AS_Volume::InfoCallback) used to report progress information.</P>

<P CLASS="Code_Ital">userdata [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="Code_Ital">volume [OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct that is to be filled in for the newly-opened volume.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceNotReady</SPAN>: no media recognized in the device.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_Close">AS_Volume_Close</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_Close releases the specified volume object and all associated memory.<BR>
<BR>
<B>NOTE</B>: To save changes before releasing the volume, first call <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A>.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_Close(AS_Volume & volume);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN&#47;OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the volume to close. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_Mount">AS_Volume_Mount</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_Mount mounts the specified volume, reading file structure information from the media on which the volume resides into the data structure created in RAM when the volume was opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>. Once the volume is mounted, changes (add&#47;delete files, folders, etc.) may be made to the structure in memory. (To write those changes back to the file system on the actual disc, see <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A>.) The parameter <I>access</I> is used to pass a flag that determines what limitations, if any, will be placed on writing to the mounted volume (see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).<BR>
<BR>
A callback with which the AuthorScript engine will report on the progress of the mount operation is specified with <I>callback</I>. The parameter <I>userdata</I> allows the host application to specify a pointer to a memory location that will be passed back whenever AuthorScript calls the callback.<BR>
<BR>
<B>NOTES</B>: <BR>
<B>&#187; </B>If the volume&#39;s file system is <SPAN CLASS="Courier_New_Inline">FS_VRT </SPAN>(custom real-time video format), <I>access</I> must be <SPAN CLASS="Courier_New_Inline">ReadOnly</SPAN>.<BR>
<B>&#187;</B> Do not attempt to mount CD-Audio, VCD, or SVCD volumes (AuthorScript AD does not currently support reading from or writing to these file system types).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_Mount(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_Volume::AccessFlag & access,<BR>
&nbsp;&nbsp;AS_Volume::InfoCallback callback,<BR>
&nbsp;&nbsp;void * userdata<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the volume to mount. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">access [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#Access flag">Access flag</A> constant (AS_Volume::AccessFlag) specifying the limitations, if any, on writing to the mounted volume.</P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Volume information callback">Volume information callback</A> (AS_Volume::InfoCallback) used to report progress information.</P>

<P CLASS="Code_Ital">userdata [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the flags are not defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: <I>access</I> included more than one flag.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume is already mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: the file system cannot be mounted.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_Create">AS_Volume_Create</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_Create mounts the specified volume and formats it in the format (ISO, UDF 1.02, UDF 2.0, etc.) specified with the parameter <I>kind</I>. A name for the newly-formatted volume is specified with <I>name</I>. Limitations, if any, on writing to the formatted volume are specified with <I>access</I>  (see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>). <BR>
<BR>
A callback with which the AuthorScript engine will report on the progress of the operation is specified with <I>callback</I>. The parameter <I>userdata</I> allows the host application to specify a pointer to a memory location that will be passed back whenever AuthorScript calls the callback.<BR>
<BR>
<B>NOTES:</B> <BR>
<B>&#187;</B> An error will result if <I>kind</I> specifies <SPAN CLASS="Courier_New_Inline">FS_TDF</SPAN>.<B><BR>
&#187;</B> An error will result if <I>access</I> specifies <SPAN CLASS="Courier_New_Inline">ReadOnly</SPAN>.<BR>
<B>&#187; </B>AuthorScript AD does not currently support reading from or writing to CD-Audio, VCD, or SVCD volumes. However, CD-R&#47;RW media formatted in these file system types may be reformatted with this function to a different file system.<BR>
<B>&#187; </B>Do not use this function if the volume&#39;s file system type is <SPAN CLASS="Courier_New_Inline">FS_VRT </SPAN>(query using <A HREF="#AS_Volume_GetProperty">AS_Volume_GetProperty</A> with <I>prop</I> set to <SPAN CLASS="Courier_New_Inline">Prop_FS_Type</SPAN>).<B><BR>
&#187;</B> To determine if the media is blank before formatting, see <A HREF="AD_Guide_6.htm#AS_StorageDevice_GetDeviceProperty">AS_StorageDevice_GetDeviceProperty</A> (blank media will also cause the <I>kind</I> parameter to output as <SPAN CLASS="Courier_New_Inline">FS_None </SPAN>when the volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>).<BR>
<B>&#187;</B> All writing to CD-R or CD-RW media is TAO (one track per session in <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>access mode; multiple tracks per session in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>access mode).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_Create(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_Volume::FS_Type & kind,<BR>
&nbsp;&nbsp;const AS_File::Path & name,<BR>
&nbsp;&nbsp;const AS_Volume::AccessFlag & access,<BR>
&nbsp;&nbsp;AS_Volume::InfoCallback callback,<BR>
&nbsp;&nbsp;void * userdata<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the volume to format. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">kind [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File system type">File system type</A> constant (AS_Volume::FS_Type) specifying the format in which the volume is to be formatted.</P>

<P CLASS="Code_Ital">name [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the name to write as the volume label.</P>

<P CLASS="Code_Ital">access [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#Access flag">Access flag</A> constant (AS_Volume::AccessFlag) specifying the limitations, if any, on writing to the formatted volume.</P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A  <A HREF="AD_Guide_5.htm#Volume information callback">Volume information callback</A> (AS_Volume::InfoCallback) used to report progress information.</P>

<P CLASS="Code_Ital">userdata [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the flags are not defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: <I>access</I> included more than one flag.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume has already been mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: the file system cannot be formatted.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_Prepare">AS_Volume_Prepare</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_Prepare prepares the volume for a flush operation by planning the volume data and returning any errors related to the planning of metadata on the media. If this function is not used prior to calling <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A>, then the planning tasks will be handled by AS_Volume_Flush instead. <BR>
<BR>
The advantage of using this call in advance of a flush is that the function may be called multiple times with no effect on the specified volume, allowing the user to check in advance if the flush operation will be successful. For example, if the call returns an error because the combined size of the files added to the volume (mastering mode) exceeds the capacity of the media, the user can remove some files and prepare the volume again, trying until the prepare operation is successful, at which point the volume can then be flushed.<BR>
<BR>
The flush operation that this call prepares for can either leave the volume border open, write a border and leave the disc appendable, or finalize write-once media (making it read-only). The parameter <I>options</I> must be used to specify one of these mutually-exclusive border options.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> If any changes are made to the volume between this call and AS_Volume_Flush, then the volume must be prepared again, either with this function or automatically during execution of AS_Volume_Flush.<BR>
<B>&#187;</B> The caller is required to specify one of the following mutually exclusive border options: <SPAN CLASS="Courier_New_Inline">Border_Open</SPAN>, <SPAN CLASS="Courier_New_Inline">Border_Close</SPAN>, <SPAN CLASS="Courier_New_Inline">Border_Final</SPAN>.<BR>
<B>&#187;</B> If this function is called prior to AS_Volume_Flush but the values of the <I>options</I> and <I>flags</I> parameters passed into AS_Volume_Flush are not the same as those passed into this call, AS_Volume_Flush will return <SPAN CLASS="Courier_New_Inline">AS_StorageErrorInvalidParameter </SPAN>unless the volume was modified between the two calls.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_Prepare(<BR>
&nbsp;&nbsp;const AS_Volume& volume,<BR>
&nbsp;&nbsp;AS_Volume::InfoCallback callback,<BR>
&nbsp;&nbsp;void * userData,<BR>
&nbsp;&nbsp;const AS_Volume::Flush_Border_Options & options,<BR>
&nbsp;&nbsp;const AS_Volume::Flush_Flags & flags = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the volume to prepare. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Volume information callback">Volume information callback</A> (AS_Volume::InfoCallback) used to report progress information.</P>

<P CLASS="Code_Ital">userData [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="Code_Ital">options [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Flush border options">Flush border options</A> constant (AS_Volume::Flush_Border_Options) specifying the border-writing setting for the flush operation.</P>

<P CLASS="Code_Ital">flags [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Flush flags">Flush flags</A> constant (AS_Volume::Flush_Flags) specifying verification for the flush operation.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the flags are not defined or no FlushOptions are provided.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume was not mounted&#47;formatted or there are open AS_File references.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: the volume&#39;s AccessFlag was read-only.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: the filesystem data and queued files cannot be written.<BR>
</P>
<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_Flush">AS_Volume_Flush</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_Flush writes file system data from RAM to the file system on the disc containing the specified volume. A callback with which the AuthorScript engine will report on the progress of the operation is specified with <I>callback</I>. The parameter <I>userdata</I> allows the host application to specify a pointer to a memory location that will be passed back whenever AuthorScript calls the callback.<BR>
<BR>
The flush operation can either leave the volume border open, write a border and leave the disc appendable, or finalize write-once media (making it read-only). The parameter <I>options</I> must be used to specify one of these mutually-exclusive border options.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> If the volume has not been modified since the most recent  AS_Volume_Prepare operation, but the values of the <I>options</I> and <I>flags</I> parameters passed into AS_Volume_Prepare were not the same as those passed into this call, this call will return <SPAN CLASS="Courier_New_Inline">AS_StorageErrorInvalidParameter</SPAN>.<B><BR>
&#187;</B> An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).<BR>
<B>&#187;</B> The entire file system is written to disc each time this function is called.<BR>
<B>&#187;</B> If the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>and the media is CD (-R or -RW) or write-once DVD, each Flush operation creates a new session on the disc (CD-RW media is not overwritten).<BR>
<B>&#187;</B> All writing to CD-R or CD-RW media is TAO (one track per session in <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>access mode; multiple tracks per session in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>access mode).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_Flush(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;AS_Volume::InfoCallback callback,<BR>
&nbsp;&nbsp;void * userData,<BR>
&nbsp;&nbsp;const AS_Volume::Flush_Border_Options & options,<BR>
&nbsp;&nbsp;const AS_Volume::Flush_Flags& flags = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the volume to flush. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Volume information callback">Volume information callback</A> (AS_Volume::InfoCallback) used to report progress information.</P>

<P CLASS="Code_Ital">userData [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="Code_Ital">options [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Flush border options">Flush border options</A> constant (AS_Volume::Flush_Border_Options) specifying the border-writing setting for the flush operation.</P>

<P CLASS="Code_Ital">flags [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Flush flags">Flush flags</A> constant (AS_Volume::Flush_Flags) specifying verification for the flush operation.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume was not mounted&#47;formatted or there are open AS_File references.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: the volume&#39;s AccessFlag was ReadOnly.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: file system data and queued files cannot be written.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_SetBootable">AS_Volume_SetBootable</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume_h.doc</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_SetBootable adds a boot file to the specified volume to make the volume bootable. The boot file is recorded to disc when the volume is flushed (see <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A>); its path is specified with the parameter <I>inBootFileOnHD</I>. The type of boot image is specified with<I> inBootType</I>; if the type is <SPAN CLASS="Courier_New_Inline">Boot_NoEmulationWithBootInfoTable</SPAN>, then the size of the boot file must be given with <I>inBootFileSizeInBytes</I>.<BR>
<BR>
<B>NOTE</B>: <BR>
<B>&#187;</B>  The boot file should be the first file on the disc.<BR>
<B>&#187;</B>  An error will result unless the volume&#39;s file system is either Joliet or an ISO type (see <A HREF="AD_Guide_5.htm#File system type">File system type</A>).<B><BR>
&#187;</B> An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).</P>

<P CLASS="SubHead_Sans11">Syntax</P>
<P CLASS="Code">
AS_StorageError AS_API AS_Volume_SetBootable(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & inBootFileOnHD,<BR>
&nbsp;&nbsp;const AS_Volume::BootType & inBootType,<BR>
&nbsp;&nbsp;UInt64 inBootFileSizeInBytes<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="SubHead_SubSans11">Input</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">inBootFileOnHD [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the full path of the boot file.</P>

<P CLASS="Code_Ital">inBootType [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Boot type">Boot type</A> constant (AS_File::BootType) specifying the type of boot image.</P>

<P CLASS="Code_Ital">inBootFileSizeInBytes [IN]</P>
<P CLASS="Def_Field">Either 0 or a Uint64 giving the size in bytes of the boot file (only if <I>inBootType</I> is <SPAN CLASS="Courier_New_Inline">Boot_NoEmulationWithBootInfoTable</SPAN>) .</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the volume&#39;s file system is not Joliet or an ISO type; or a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: <I>access</I> included more than one flag.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume has already been mounted.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_GetProperty">AS_Volume_GetProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_GetProperty retrieves the value of a property of the specified volume. The parameter <I>prop</I> indicates the property (format, state, name, block size, free blocks, date modified, date created, etc.) for which to retrieve the current value. The value is output to a buffer pointed to with <I>propData</I>, the size of which is specified with <I>bufLen</I>. The actual size of the data written to the buffer is output with <I>propSize</I>. The remaining parameters are currently reserved for future use.<BR>
<BR>
<B>NOTE</B>: Some properties are only available to query when the volume is mounted.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_GetProperty(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_Volume::Property & prop,<BR>
&nbsp;&nbsp;UInt32 bufLen,<BR>
&nbsp;&nbsp;void * propData,<BR>
&nbsp;&nbsp;UInt32 * propSize,<BR>
&nbsp;&nbsp;UInt32 PropertyIndex = 0,<BR>
&nbsp;&nbsp;UInt32 extbufLen = 0,<BR>
&nbsp;&nbsp;void * extpropData = 0,<BR>
&nbsp;&nbsp;UInt32 * extpropSize = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the volume whose property is to be retrieved. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">prop [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Volume property">Volume property</A> enum (AS_Volume::Property) specifying the property for which the value is to be retrieved. </P>

<P CLASS="Code_Ital">bufLen [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size of the buffer pointed to with <I>propData</I>.</P>

<P CLASS="Code_Ital">propData [OUT]</P>
<P CLASS="Def_Field">A pointer to a buffer to be filled in with the value of the property specified with <I>prop</I>.</P>

<P CLASS="Code_Ital">propSize [OUT]</P>
<P CLASS="Def_Field">A UInt32 indicating the size of the data written to <I>propData</I>.</P>

<P CLASS="Code_Ital">PropertyIndex [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extbufLen [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropData [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropSize [OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined or the property cannot be retrieved.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_BufferOverflow</SPAN>: <I>propData</I> is too small to contain the property data.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the property cannot be obtained in the current volume state.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_SetProperty">AS_Volume_SetProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Volume Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_SetProperty sets the value of a property of the specified volume. The parameter <I>prop</I> indicates the property (e.g. name, date modified, date created, path delimiter) for which the value is to be set. The value itself is given in the buffer pointed to with <I>propData</I>, the size of which is specified with <I>propSize</I>. The remaining parameters are currently reserved for future use.<BR>
<BR>
<B>NOTE</B>:<BR>
<B>&#187; </B>An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).<B><BR>
&#187; </B>An error will result unless the property specified with <I>prop</I> is either name, date modified, date created, or path delimiter (see <A HREF="AD_Guide_5.htm#AS_Volume_Property">AS_Volume_Property</A>).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_SetProperty(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_Volume::Property & prop,<BR>
&nbsp;&nbsp;UInt32 propSize,<BR>
&nbsp;&nbsp;void * propData,<BR>
&nbsp;&nbsp;UInt32 PropertyIndex = 0,<BR>
&nbsp;&nbsp;UInt32 extbufLen = 0,<BR>
&nbsp;&nbsp;void * extpropData = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct specifying the volume whose property is to be set. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">prop [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Volume property">Volume property</A> enum (AS_Volume::Property) specifying the property for which the value is to be set. </P>

<P CLASS="Code_Ital">propSize [IN]</P>
<P CLASS="Def_Field">A UInt32 indicating the size of the data in the <I>propData</I> buffer.</P>

<P CLASS="Code_Ital">propData [IN]</P>
<P CLASS="Def_Field">A pointer to a buffer containing the value to which the property is to be set.</P>

<P CLASS="Code_Ital">PropertyIndex [IN]</P>
<P CLASS="Def_Field">Optional: index of list of property returned</P>

<P CLASS="Code_Ital">extbufLen [IN]</P>
<P CLASS="Def_Field">Optional: size available in extpropData buffer</P>

<P CLASS="Code_Ital">extpropData [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: extended buffer to copy property value into</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_BufferOverflow</SPAN>: <I>propData</I> is too small to contain the property data.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: AS_Volume::AccessFlag = ReadOnly.</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Directory and File Creation">7.2 &nbsp;Directory and File Creation</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section covers the following calls:</P>

<P CLASS="LinksList"><A HREF="#AS_Volume_CreateEntry">AS_Volume_CreateEntry</A>, <A HREF="#AS_Volume_CreateEntryFromHD">AS_Volume_CreateEntryFromHD</A>, <A HREF="#AS_Volume_CreateFileFromStream">AS_Volume_CreateFileFromStream</A>, <A HREF="#AS_Volume_DeleteEntry">AS_Volume_DeleteEntry</A></P>
<P CLASS="IndentSerif">These calls are used to create and delete files and directories.<BR>
<BR>
<B>NOTE</B>: The device containing the target volume should be reserved (see <A HREF="AD_Guide_6.htm#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using any of the functions in this section.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_CreateEntry">AS_Volume_CreateEntry</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Creation">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_CreateEntry creates a file system object on the specified volume. The kind of file system object to create (file or directory) is specified with the parameter <I>kind</I>. The name of the object and the directory location at which it is to be created are specified with <I>fullPath</I>. If the parents in this path do not already exist in the volume, they may be created automatically by setting <I>createParents</I> to true.<BR>
<BR>
<B>NOTES:<BR>
&#187; </B>An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).<B><BR>
&#187; </B>An error will result if <I>createParents</I> is given as false and any parent indicated in <I>fullPath</I> does not already exist.<BR>
<B>&#187; </B>If <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A> is called with the <I>mode</I> parameter set to <SPAN CLASS="Courier_New_Inline">Append </SPAN>and the parents in the path specified with that call&#39;s <I>fullPath</I> parameter already exist, then a file will be created automatically without the use of this call.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_CreateEntry(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & fullPath,<BR>
&nbsp;&nbsp;const AS_File::Kind & kind,<BR>
&nbsp;&nbsp;const AS_File::CreateFlags & flags<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">fullPath [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) that specifies the full path&#47;name of the file.</P>

<P CLASS="Code_Ital">kind [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File kind">File kind</A> constant (AS_File::Kind) specifying the kind of file system object (directory or file) to create.</P>

<P CLASS="Code_Ital">flags[IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Create flags">Create flags</A> constant (AS_File::CreateFlags) specifying the type of create operation to perform.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>:  the volume has not been formatted&#47;mounted, or createParents = FALSE and the parent directory doesn&#39;t exist in fullPath.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: AS_Volume::AccessFlag = ReadOnly.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unable to create an entry.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_CreateEntryFromHD">AS_Volume_CreateEntryFromHD</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Creation">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_CreateEntryFromHD creates an entry (file or directory) on the specified volume from a source entry on a hard drive. The source entry is specified with <I>fullPathOnHD</I>. The name of the newly-created entry and the directory location at which it is to be created are specified with the parameter <I>fullPath</I>. Space is allocated when the entry is created, but the space remains empty until the volume is flushed with <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A>, at which point the source file or directory data is copied to disc.<BR>
<BR>
<B>NOTES</B>: <BR>
<B>&#187;</B> This function should be used when the amount of data to be written is known in advance of the recording. If the amount of data will not be known in advance, see instead <A HREF="#AS_File_Write">AS_File_Write</A>.<BR>
<B>&#187;</B> The preferred access mode when using this function is <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>). An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly</SPAN>. <BR>
<B>&#187;</B> All writing to CD-R or CD-RW media is TAO (one track per session in <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>access mode; multiple tracks per session in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>access mode).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_CreateEntryFromHD(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & fullPath,<BR>
&nbsp;&nbsp;const AS_File::Path & fullPathOnHD,<BR>
&nbsp;&nbsp;const AS_File::CreateFlags & flags<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">fullPath [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) that specifies the full path&#47;name of the newly-created entry.</P>

<P CLASS="Code_Ital">fullPathOnHD [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) that specifies the full path&#47;name of the source entry.</P>

<P CLASS="Code_Ital">flags[IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Create flags">Create flags</A> constant (AS_File::CreateFlags) specifying the type of create operation to perform.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>:  the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: AS_Volume::AccessFlag = ReadOnly.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_FileExists</SPAN>: the file referenced by <I>fullPath</I> already exists.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unable to create an entry.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_CreateFileFromStream">AS_Volume_CreateFileFromStream</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Creation">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_CreateFileFromStream creates a file on the specified volume from a stream. The name of the newly-created file and the directory location at which it is to be created are specified with the parameter <I>fullPath</I>. <BR>
<BR>
Space for the file is allocated based on the size specified with <I>streamLength</I> when the file is created, but the space remains empty until the volume is flushed with <A HREF="#AS_Volume_Flush">AS_Volume_Flush</A>, at which point the stream data is requested using the callback specified with <I>callback</I>. The parameter <I>userdata</I> allows the host application to specify a pointer to a memory location that will be passed back whenever AuthorScript calls the callback.<BR>
<BR>
<B>NOTES</B>: <BR>
<B>&#187;</B> This function should be used when the amount of data to be written is known in advance of the recording. If the amount of data will not be known in advance, see instead <A HREF="#AS_File_Write">AS_File_Write</A>.<BR>
<B>&#187;</B> The preferred access mode when using this function is <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>). An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly</SPAN>. <BR>
<B>&#187;</B> All writing to CD-R or CD-RW media is TAO (one track per session in <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>access mode; multiple tracks per session in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>access mode).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_CreateFileFromStream(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & fullPath,<BR>
&nbsp;&nbsp;const AS_File::Size & streamLength,<BR>
&nbsp;&nbsp;AS_Volume::StreamCallback callback,<BR>
&nbsp;&nbsp;void * userdata,<BR>
&nbsp;&nbsp;const AS_File::CreateFlags & flags<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">fullPath [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the full path&#47;name of the newly-created entry.</P>

<P CLASS="Code_Ital">streamLength [IN]</P>
<P CLASS="Def_Field">A constant reference to a Uint64 of type <A HREF="AD_Guide_5.htm#AS_File">AS_File</A>::Size specifying how much space to allocate for the new file.</P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Stream callback">Stream callback</A> (AS_Volume::StreamCallback) specifying the procedure to be called by the AuthorScript engine to fill buffers with stream data.</P>

<P CLASS="Code_Ital">userdata [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="Code_Ital">flags[IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Create flags">Create flags</A> constant (AS_File::CreateFlags) specifying the type of create operation to perform.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>:  the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: AS_Volume::AccessFlag = ReadOnly.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_FileExists</SPAN>: the file referenced by <I>fullPath</I> already exists.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unable to create an entry.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_DeleteEntry">AS_Volume_DeleteEntry</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Creation">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_DeleteEntry deletes one or more file system objects on the specified volume. The specific action performed by the call depends on the kind (file or directory) of the object and, if the object is a directory, whether or not that directory is empty:</P>
<UL CLASS="IndentSerif_List"><LI>if object specified with the parameter <I>fullPath</I> is a file, that file alone is deleted;</LI>
<LI>if the object is a directory (empty or not) and <I>deleteChildren</I> is passed as &quot;true&quot; then that directory and its entire contents are all deleted;</LI>
<LI>if the object is an empty directory and <I>deleteChildren</I> is passed as &quot;false&quot; then the directory is deleted;</LI>
<LI>if the object is a directory that is not empty and <I>deleteChildren</I> is passed as &quot;false&quot; then the call results in an error.</LI></UL>
<P CLASS="IndentSerif"><B>NOTE</B>: An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_DeleteEntry(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & fullPath,<BR>
&nbsp;&nbsp;const AS_File::DeleteFlags & flags<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="SubHead_SubSans11">Input</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">fullPath [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the full path&#47;name of the file to delete.</P>

<P CLASS="Code_Ital">flags[IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#Delete flags">Delete flags</A> constant (AS_File::DeleteFlags) specifying the type of delete operation to perform.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>:  the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: AS_Volume::AccessFlag = ReadOnly.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_FileExists</SPAN>: the entry referenced by <I>fullPath</I> does not exist.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unable to delete specified entry.</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Directory and File Information">7.3 &nbsp;Directory and File Information</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section covers the following calls:</P>

<P CLASS="LinksList"><A HREF="#AS_Volume_GetEntryInfo">AS_Volume_GetEntryInfo</A>, <A HREF="#AS_Volume_GetEntry">AS_Volume_GetEntry</A>, <A HREF="#AS_Volume_GetEntryProperty">AS_Volume_GetEntryProperty</A>, <A HREF="#AS_Volume_SetEntryProperty">AS_Volume_SetEntryProperty</A>, <A HREF="#AS_File_GetProperty">AS_File_GetProperty</A>, <A HREF="#AS_File_SetProperty">AS_File_SetProperty</A></P>
<P CLASS="IndentSerif">These calls are used to get information about files and directories, and to get and set their properties. For a comparison of two different approaches to getting and setting properties, see <A HREF="AD_Guide_3.htm#Property Get and Set Methods"><SPAN CLASS="Arial_Inline"><B>Property Get and Set Methods</B></SPAN></A>.<BR>
<BR>
<B>NOTE</B>: The device containing the target volume or file should be reserved (see <A HREF="AD_Guide_6.htm#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using any of the functions in this section.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_GetEntryInfo">AS_Volume_GetEntryInfo</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Information">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_GetEntryInfo is used to get information about a file system entry (file or directory) in the specified volume. The path to the object is specified with the parameter <I>path</I>, while the parameter <I>kind</I> is used to report back on whether the object at that path is a file or a directory. If the object is a file, its size is output with <I>size</I>. If it is a directory, <I>size</I> is used to output the number of entries in that directory.<BR>
<BR>
<B>NOTE</B>: For more detailed information about an entry, use <A HREF="#AS_Volume_GetEntryProperty">AS_Volume_GetEntryProperty</A> (files or directories) or <A HREF="#AS_File_GetProperty">AS_File_GetProperty</A> (files only).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_GetEntryInfo(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & path,<BR>
&nbsp;&nbsp;AS_File::Kind & kind,<BR>
&nbsp;&nbsp;AS_File::Size & size<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">path [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the path to the directory or file.</P>

<P CLASS="Code_Ital">kind [OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#File kind">File kind</A> object (AS_File::Kind) that is to be filled in with a constant indicating the kind of file system entry.</P>

<P CLASS="Code_Ital">size [OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#File size">File size</A> object (AS_File::Size) that is to be filled in with one of the following:<BR>
- if <I>path</I> specifies a directory, the number of entries in that directory;<BR>
- if <I>path</I> specifies a file, the file&#39;s logical size.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>:  the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_FileNotFound </SPAN>- the path doesn&#39;t exist in the volume.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_GetEntry">AS_Volume_GetEntry</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Information">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_GetEntry retrieves the name of the file system object (file or directory) at a given index (zero-based) in a directory on the specified volume. The path to the directory is specified with <I>inFullPath</I>, while the target object&#39;s index within that directory is specified with <I>idx</I> (the value of which must be less than the directory&#39;s size as output from <A HREF="#AS_Volume_GetEntryInfo">AS_Volume_GetEntryInfo</A>).<BR>
<BR>
The amount of memory to set aside for the retrieved name is specified with <I>bufLen</I>. If that memory is not sufficient for the actual name at the specified location, the amount needed for the name will be output with <I>pathLen</I>. The path and name itself will be output with <I>outFullPath</I>.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_GetEntry(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & infullPath,<BR>
&nbsp;&nbsp;SInt32 idx,<BR>
&nbsp;&nbsp;SInt32 * pathLen,<BR>
&nbsp;&nbsp;AS_File::Path & outFullPath<BR>
);</P>

<P CLASS="SubHead_Sans11">Returned Value</P>

<P CLASS="Code_Ital">AS_Error</P>
<P CLASS="Def_Field">An enumerator of type <A HREF="AD_Guide_5.htm#AS_Error">AS_Error</A> giving an error code indicating the outcome of the call. If the function completed successfully, the error code = 0.</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">inFullPath [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the path to the directory.</P>

<P CLASS="Code_Ital">idx [IN]</P>
<P CLASS="Def_Field">An SInt32 specifying the index of the item within the directory.</P>

<P CLASS="Code_Ital">pathLen [OUT]</P>
<P CLASS="Def_Field">A pointer to the SInt32 that is to be filled in with either the length of <I>outFullPath</I> (if the size of <I>outFullPath</I> is greater than <I>pathLen</I>) or NULL.</P>

<P CLASS="Code_Ital">outFullPath [OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#File path">File path</A> object (AS_File::Path) that is to be filled in with the full path and name of the file system object at the location specified with <I>inFullPath</I> and <I>idx</I>.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>:  the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidIndex</SPAN>: <I>idx</I> is greater than the count of items in the directory.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_FolderNotFound </SPAN>- the directory path could not be found.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_GetEntryProperty">AS_Volume_GetEntryProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Information">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_GetEntryProperty retrieves the value of a property of a file or directory on the specified volume. The file is identified by its full path, specified with the parameter <I>path</I>.<BR>
<BR>
The parameter <I>prop</I> indicates the property (end-of-file, state, date modified, date created, etc.) for which to retrieve the current value. The value is output to a buffer specified with <I>propData</I>, the size of which is specified with <I>bufLen</I>. The actual size of the data written to the buffer is output with <I>propSize</I>. The remaining parameters are currently reserved for future use.<BR>
<BR>
<B>NOTE</B>: To retrieve property information for a file using that file&#39;s reference (<A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct) instead, see <A HREF="#AS_File_GetProperty">AS_File_GetProperty</A>.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_GetEntryProperty(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & path,<BR>
&nbsp;&nbsp;const AS_File::Property & prop,<BR>
&nbsp;&nbsp;UInt32 bufLen,<BR>
&nbsp;&nbsp;void * propData,<BR>
&nbsp;&nbsp;UInt32 * propSize,<BR>
&nbsp;&nbsp;UInt32 PropertyIndex = 0,<BR>
&nbsp;&nbsp;UInt32 extbufLen = 0,<BR>
&nbsp;&nbsp;void * extpropData = 0,<BR>
&nbsp;&nbsp;UInt32 * extpropSize = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">path [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the path of the file.</P>

<P CLASS="Code_Ital">prop [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File property">File property</A>  enum (AS_File::Property) specifying the property for which the value is to be retrieved. </P>

<P CLASS="Code_Ital">bufLen [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size of the buffer pointed to with <I>propData</I>.</P>

<P CLASS="Code_Ital">propData [OUT]</P>
<P CLASS="Def_Field">A pointer to a buffer to be filled in with the value of the property specified with <I>prop</I>.</P>

<P CLASS="Code_Ital">propSize [OUT]</P>
<P CLASS="Def_Field">A UInt32 indicating the amount of data written to <I>propData</I>.</P>

<P CLASS="Code_Ital">PropertyIndex [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extbufLen [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropData [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropSize [OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_BufferOverflow</SPAN>: <I>propData</I> is too small to contain the property data.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_SetEntryProperty">AS_Volume_SetEntryProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Information">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_SetEntryProperty sets the value of a property of a file or directory on the specified volume. The file is identified by its full path, specified with the parameter <I>path</I>. To set a property for a file using that file&#39;s reference (<A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct) instead, see <A HREF="#AS_File_GetProperty">AS_File_GetProperty</A>.<BR>
<BR>
The parameter <I>prop</I> indicates the property (end-of-file, state, date modified, date created, etc.) for which to set the value. The value itself is given in the buffer specified with <I>propData</I>, the size of which is specified with <I>propSize</I>.<BR>
<BR>
<B>NOTE</B>:<BR>
<B>&#187;</B> An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).<BR>
<B>&#187;</B> An error will result if you attempt to set the size of the entry (value of <I>prop</I> given as <SPAN CLASS="Courier_New_Inline">Prop_Size = 2</SPAN>).<BR>
<B>&#187;</B> If the value of <I>prop</I> is <SPAN CLASS="Courier_New_Inline">Prop_Name = 1</SPAN>, an error will result unless the path given with <I>propData</I> indicates the same directory as the existing path given with <I>path</I>.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_SetEntryProperty(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & path,<BR>
&nbsp;&nbsp;const AS_File::Property & prop,<BR>
&nbsp;&nbsp;UInt32 propSize,<BR>
&nbsp;&nbsp;void * propData,<BR>
&nbsp;&nbsp;UInt32 PropertyIndex = 0,<BR>
&nbsp;&nbsp;UInt32 extbufLen = 0,<BR>
&nbsp;&nbsp;void * extpropData = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the target volume. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">path [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the path of the file.</P>

<P CLASS="Code_Ital">prop [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File property">File property</A> enum (AS_File::Property) specifying the property for which the value is to be retrieved. </P>

<P CLASS="Code_Ital">propSize [IN]</P>
<P CLASS="Def_Field">A UInt32 indicating the size of the data in the <I>propData</I> buffer.</P>

<P CLASS="Code_Ital">propData [IN]</P>
<P CLASS="Def_Field">A pointer to a buffer containing the value to which the property is to be set.</P>

<P CLASS="Code_Ital">PropertyIndex [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extbufLen [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropData [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined. <BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_BufferOverflow</SPAN>: <I>propData</I> is too small to contain the property data.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: the volume&#39;s AccessFlag was <SPAN CLASS="Courier_New_Inline">ReadOnly</SPAN>.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_File_GetProperty">AS_File_GetProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Information">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_File.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_File_GetProperty retrieves the value of a property of a file. The file, which must already be open (see <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>), is identified by the reference (<A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct) specified with the parameter <I>file</I>. To retrieve property information for a file using that file&#39;s path instead, see <A HREF="#AS_Volume_GetEntryProperty">AS_Volume_GetEntryProperty</A>.<BR>
<BR>
The parameter <I>prop</I> indicates the property (end-of-file, state, date modified, date created, etc.) for which to retrieve the current value. The value is output to a buffer specified with <I>propData</I>, the size of which is specified with <I>bufLen</I>. The actual size of the data written to the buffer is output with <I>propSize</I>. The remaining parameters are currently reserved for future use.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_File_GetProperty(<BR>
&nbsp;&nbsp;const AS_File & file,<BR>
&nbsp;&nbsp;const AS_File::Property & prop,<BR>
&nbsp;&nbsp;UInt32 bufLen,<BR>
&nbsp;&nbsp;void * propData,<BR>
&nbsp;&nbsp;UInt32 * propSize,<BR>
&nbsp;&nbsp;UInt32 PropertyIndex = 0,<BR>
&nbsp;&nbsp;UInt32 extbufLen = 0,<BR>
&nbsp;&nbsp;void * extpropData = 0,<BR>
&nbsp;&nbsp;UInt32 * extpropSize = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">file [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct for the target file, which must already be open. An AS_File struct is output when the file is opened with <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>.</P>

<P CLASS="Code_Ital">prop [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File property">File property</A> enum (AS_File::Property) specifying the property for which the value is to be retrieved.</P>

<P CLASS="Code_Ital">bufLen [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size of the buffer pointed to with <I>propData</I>.</P>

<P CLASS="Code_Ital">propData [OUT]</P>
<P CLASS="Def_Field">A pointer to a buffer to be filled in with the value of the property specified with <I>prop</I>.</P>

<P CLASS="Code_Ital">propSize [OUT]</P>
<P CLASS="Def_Field">A UInt32 indicating the amount of data written to <I>propData</I>.</P>

<P CLASS="Code_Ital">PropertyIndex [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extbufLen [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropData [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropSize [OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_BufferOverflow</SPAN>: <I>propData</I> is too small to contain the property data.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_File_SetProperty">AS_File_SetProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Directory and File Information">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_ File.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_File_SetProperty sets the value of a property of a file. The file, which must already be open (see <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>), is identified by the reference (<A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct) specified with the parameter <I>file</I>. To set property information for a file using that file&#39;s path instead, see <A HREF="#AS_Volume_SetEntryProperty">AS_Volume_SetEntryProperty</A>.<BR>
<BR>
The parameter <I>prop</I> indicates the property (end-of-file, state, date modified, date created, etc.) for which to set the value. The value itself is given in the buffer specified with <I>propData</I>, the size of which is specified with <I>propSize</I>. The remaining parameters are currently reserved for future use.<BR>
<BR>
<B>NOTE</B>:<BR>
<B>&#187;</B> An error will result if the volume&#39;s access mode is <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).<BR>
<B>&#187;</B> An error will result if you attempt to set the size of the entry (value of <I>prop</I> given as <SPAN CLASS="Courier_New_Inline">Prop_Size = 2</SPAN>).<BR>
<B>&#187;</B> If the value of <I>prop</I> is <SPAN CLASS="Courier_New_Inline">Prop_Name = 1</SPAN>, an error will result unless the file path given with <I>propData</I> indicates the same directory as the path of the file referenced with <I>file</I>.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_File_SetProperty(<BR>
&nbsp;&nbsp;const AS_File & file,<BR>
&nbsp;&nbsp;const AS_File::Property & prop,<BR>
&nbsp;&nbsp;UInt32 propSize,<BR>
&nbsp;&nbsp;void * propData,<BR>
&nbsp;&nbsp;UInt32 PropertyIndex = 0,<BR>
&nbsp;&nbsp;UInt32 extbufLen = 0,<BR>
&nbsp;&nbsp;void * extpropData = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Returned Value</P>

<P CLASS="Code_Ital">AS_Error</P>
<P CLASS="Def_Field">An enumerator of type <A HREF="AD_Guide_5.htm#AS_Error">AS_Error</A> giving an error code indicating the outcome of the call. If the function completed successfully, the error code = 0.</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">file [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct for the target file, which must already be open. An AS_File struct is output when the file is opened with <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>.</P>

<P CLASS="Code_Ital">prop [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File property">File property</A> enum (AS_File::Property) specifying the property for which the value is to be set.</P>

<P CLASS="Code_Ital">propSize [IN]</P>
<P CLASS="Def_Field">A UInt32 indicating the size of the data in the <I>propData</I> buffer.</P>

<P CLASS="Code_Ital">propData [IN]</P>
<P CLASS="Def_Field">A pointer to a buffer containing the value to which the property is to be set.</P>

<P CLASS="Code_Ital">PropertyIndex [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extbufLen [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">extpropData [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume has not been formatted&#47;mounted.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_BufferOverflow</SPAN>: <I>propData</I> is too small to contain the property data.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: the volume&#39;s AccessFlag was <SPAN CLASS="Courier_New_Inline">ReadOnly</SPAN>.</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="File Read and Write">7.4 &nbsp;File Read and Write</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section covers the following calls:</P>

<P CLASS="LinksList"><A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>, <A HREF="#AS_File_Close">AS_File_Close</A>, <A HREF="#AS_File_Seek">AS_File_Seek</A>, <A HREF="#AS_File_Read">AS_File_Read</A>, <A HREF="#AS_File_Write">AS_File_Write</A></P>
<P CLASS="IndentSerif">These calls are used when reading and writing data to and from files.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> <A HREF="#AS_File_Write">AS_File_Write</A> is the preferred recording method only when the amount of data to be written is not known in advance of the recording. If the amount of data will be known in advance, see instead <A HREF="#AS_Volume_CreateEntryFromHD">AS_Volume_CreateEntryFromHD</A> or <A HREF="#AS_Volume_CreateFileFromStream">AS_Volume_CreateFileFromStream</A>.<BR>
<B>&#187;</B> Support for writing to files depends on the volume&#39;s media kind, file system, and access mode. For further information, see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>.<B><BR>
&#187; </B>The device containing the target volume or file should be reserved (see <A HREF="AD_Guide_6.htm#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using any of the functions in this section.</P>

<P CLASS="SubHead_Sans12"><A ID="Read&#47;Write call sequence">Read&#47;Write call sequence</A></P>
<P CLASS="IndentSerif">The steps involved in setting up to read from or write to a file would typically be as follows:</P>
<OL CLASS="IndentSerif_NumList"><LI><A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A> opens the file in either read or append mode.</LI>
<LI>If the file is in read mode and the desired starting location for the read operation is not 0 (beginning of file), use <A HREF="#AS_File_Seek">AS_File_Seek</A> to position the starting location. If the file is in append mode, the position will always be the end of the file (EOF).</LI>
<LI>Once the file is open and the correct location is set, the file may be read from with <A HREF="#AS_File_Read">AS_File_Read</A> if the open mode was read, or written to with <A HREF="#AS_File_Write">AS_File_Write</A> if the open mode was append.</LI>
<LI>To change the open mode of the file (from read to append or vice versa), first close the file with <A HREF="#AS_File_Close">AS_File_Close</A>, then call AS_Volume_OpenFile again, specifying the new mode.</LI></OL>
<P CLASS="IndentSerif"><B>NOTE</B>:<BR>
<B>&#187;</B> While it may be possible (depending on the drives and media involved) for a given file to be simultaneously open in read mode in one thread and append mode in a different thread, this condition is not currently recommended or supported.<BR>
<B>&#187;</B> AuthorScript AD does not write sectors in Data Mode 2 format or open any volume that contains them.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_Volume_OpenFile">AS_Volume_OpenFile</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#File Read and Write">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_Volume.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_Volume_OpenFile opens a file on the specified volume and retrieves a file reference for that file. Output with the parameter <I>file</I>, the reference may be used in subsequent calls that seek within, read from or write to the file. The file to open is specified with <I>fullPath</I>; the mode in which the file is to be opened (read or append) is specified with <I>mode</I>. <BR>
<BR>
When the open mode is specified as read, the file position defaults to 0 (beginning of file). Use <A HREF="#AS_File_Seek">AS_File_Seek</A> to change the location. When the open mode is append, the file position defaults to EOF (end-of-file) unless the specified file does not exist on the volume, in which case the file will be created. AS_File_Seek calls are not allowed while in append mode.<BR>
<BR>
<B>NOTES:<BR>
&#187;</B> When re-opening an existing file, if <I>mode</I> is specified as <SPAN CLASS="Courier_New_Inline">Append </SPAN>then an error will result unless the size of the file indicated with <I>fullPath</I> is a multiple of 2048 bytes.<BR>
<B>&#187;</B> If <I>mode</I> is specified as <SPAN CLASS="Courier_New_Inline">Append</SPAN>, an error will result if the volume&#39;s current combination of media kind, file system, and access mode does not allow writing to files. For further information, see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>.<BR>
<B>&#187;</B> If <I>mode</I> is specified as <SPAN CLASS="Courier_New_Inline">Append </SPAN>and the parents in the path specified with <I>fullPath</I> already exist, then a new file will be created automatically if a file of the specified name does not already exist.<BR>
<B>&#187;</B> Once opened in read mode, a file must be closed (see <A HREF="#AS_File_Close">AS_File_Close</A>) and then reopened in append mode in order to write to it. Similarly, a file opened in append mode must be closed and then reopened in read mode in order to read from it.<BR>
<B>&#187;</B> To get or set the properties of a file opened with this call, see <A HREF="#AS_File_GetProperty">AS_File_GetProperty</A> or <A HREF="#AS_File_SetProperty">AS_File_SetProperty</A>.<BR>
<B>&#187;</B> If the media is CD or write-once DVD and the access mode of the volume is <SPAN CLASS="Courier_New_Inline">RTTD</SPAN>, the file system of the volume must be UDF 1.5 or greater.<SPAN CLASS="Monaco_Inline"><BR>
</SPAN>&#187; All writing to CD-R or CD-RW media is TAO (one track per session in <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>access mode; multiple tracks per session in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>access mode).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_Volume_OpenFile(<BR>
&nbsp;&nbsp;const AS_Volume & volume,<BR>
&nbsp;&nbsp;const AS_File::Path & fullPath,<BR>
&nbsp;&nbsp;const AS_File::OpenMode & mode,<BR>
&nbsp;&nbsp;AS_File & file<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">volume [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_Volume">AS_Volume</A> struct for the volume containing the file to open. An AS_Volume struct is output when a volume is opened with <A HREF="#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>.</P>

<P CLASS="Code_Ital">fullPath [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File path">File path</A> string (AS_File::Path) specifying the full path&#47;name of the file.</P>

<P CLASS="Code_Ital">mode [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#Open mode">Open mode</A> enum (AS_File::OpenMode) specifying the mode in which the file is to be opened.</P>

<P CLASS="Code_Ital">file [OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct that is to be filled in for the newly-opened file.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined. <BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidAccess</SPAN>: the mode is set to append and writing in RTTD mode is not allowed for volume.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the volume has not been formatted&#47;mounted; there is already an open AS_File reference for the file; or <SPAN CLASS="Courier_New_Inline">OpenMode </SPAN>is set to append and the file length is not a multiple of the block size.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: with mode set to append, unable to create or write to the file.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_File_Close">AS_File_Close</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#File Read and Write">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_ File.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_File_Close closes the specified file to further reading or writing and releases the file&#39;s reference and associated memory.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_File_Close(AS_File & file);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">file [IN&#47;OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct for the file to close. An AS_File struct is output when a file is opened with <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined. <BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: the file could not be closed.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_File_Seek">AS_File_Seek</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#File Read and Write">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_ File.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_File_Seek sets the location in the specified file that will be the starting position of the next read operation. The location, specified with the parameter <I>toPos</I>, is given as an offset (in bytes) from the start of the file.<BR>
<BR>
<B>NOTE</B>: An error will result if the file referenced with <I>file</I> was opened in append mode (see <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_File_Seek(<BR>
&nbsp;&nbsp;const AS_File & file,<BR>
&nbsp;&nbsp;const AS_File::Size & toPos<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">file [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct specifying the file to seek in, starting at its current position. An AS_File struct is output when the file is opened with <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>.</P>

<P CLASS="Code_Ital">toPos [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File size">File size</A> UInt64 (AS_File::Size) specifying an offset in bytes from the start of the file to the location at which to start the next read operation.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the file was opened in append mode.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_File_Read">AS_File_Read</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#File Read and Write">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_File.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_File_Read reads data from the specified file into the buffer specified with the parameter <I>buffer</I>, the size of which is specified with <I>numBytes</I>. When the call executes, the amount of data actually read into the buffer is output with <I>numRead</I>.<BR>
<BR>
The file will be read from its current location. By default, that location is set to 0 (beginning of file) when a file is opened in read mode (see <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>). Use <A HREF="#AS_File_Seek">AS_File_Seek</A> to seek to a different location.<BR>
<BR>
<B>NOTE</B>: The file must already be open and in read mode (see AS_Volume_OpenFile). If the file was opened in append mode, it must first be closed and then reopened in read mode.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_File_Read(<BR>
&nbsp;&nbsp;const AS_File & file,<BR>
&nbsp;&nbsp;const AS_File::Count & numBytes,<BR>
&nbsp;&nbsp;void * buffer,<BR>
&nbsp;&nbsp;AS_File::Count * numRead<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">file [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct specifying the file to read (from current location). An AS_File struct is output when a file is opened with <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>.</P>

<P CLASS="Code_Ital">numBytes [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File count">File count</A> UInt32 (AS_File::Count) specifying the number of bytes to read.</P>

<P CLASS="Code_Ital">buffer [IN]</P>
<P CLASS="Def_Field">A pointer to the buffer to which the read data should be written.</P>

<P CLASS="Code_Ital">numRead [OUT]</P>
<P CLASS="Def_Field">A pointer to the <A HREF="AD_Guide_5.htm#File count">File count</A> UInt32 (AS_File::Count) that is to be filled in with the number of bytes actually read.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined. <BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the file was opened in append mode.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unable to read from file.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_File_Write">AS_File_Write</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#File Read and Write">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_ File.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_File_Write writes data to the end of the specified file from the buffer specified with the parameter <I>buffer</I>. The amount of data to write from the buffer is specified with <I>numBytes</I>. When the call executes, the amount of data actually written to the file is output with <I>numWrote</I>.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> This function should only be used when the amount of data to be written is not known in advance of the recording. If the amount of data will be known in advance, see <A HREF="#AS_Volume_CreateEntryFromHD">AS_Volume_CreateEntryFromHD</A> or <A HREF="#AS_Volume_CreateFileFromStream">AS_Volume_CreateFileFromStream</A>.<B><BR>
&#187;</B> The file must already be open and in append mode (see <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>). If the file was opened in read mode, it must first be closed and then reopened in append mode.<BR>
<B>&#187;</B> The access mode of the volume (see <A HREF="AD_Guide_5.htm#Access flag">Access flag</A>) must be <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>(see <A HREF="AD_Guide_3.htm#Access Mode, File System, and Media"><SPAN CLASS="Arial_Inline"><B>Access Mode, File System, and Media</B></SPAN></A>).<BR>
<B>&#187; </B>If the media is CD or write-once DVD, the file system of the volume must be UDF 1.5 or greater. <BR>
<B>&#187;</B> All writing to CD-R or CD-RW media is TAO (one track per session in <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>access mode; multiple tracks per session in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>access mode).</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_File_Write(<BR>
&nbsp;&nbsp;const AS_File & file,<BR>
&nbsp;&nbsp;const AS_File::Count & numBytes,<BR>
&nbsp;&nbsp;void * buffer,<BR>
&nbsp;&nbsp;AS_File::Count * numWrote<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">file [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct specifying the file to write to (starting at current location). An AS_File struct is output when a file is opened with <A HREF="#AS_Volume_OpenFile">AS_Volume_OpenFile</A>.</P>

<P CLASS="Code_Ital">numBytes [IN]</P>
<P CLASS="Def_Field">A constant reference to a <A HREF="AD_Guide_5.htm#File count">File count</A> UInt32 (AS_File::Count) specifying the number of bytes to write.</P>

<P CLASS="Code_Ital">buffer [IN]</P>
<P CLASS="Def_Field">A pointer to the buffer from which the data should be written.</P>

<P CLASS="Code_Ital">numWrote [OUT]</P>
<P CLASS="Def_Field">A pointer to the <A HREF="AD_Guide_5.htm#File count">File count</A> UInt32 (AS_File::Count) that is to be filled in with the number of bytes actually written.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: a parameter is not correctly defined. <BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidOperation</SPAN>: the file was not opened in append mode.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unable to write to file.</P>

<P CLASS="IndentSans"><A HRef= "#chapter">Top</A></P>
</BODY>
</HTML>

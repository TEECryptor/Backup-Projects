<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>AuthorScript&#174; Advanced Data 3.2 SDK Guide - Chapter 5</TITLE>
<!-- AuthorScript Advanced Data SDK version 3.2 -->
<!-- HTML version generated by DelPhi on 060707 -->
<!-- (c) 2002-2007 Sonic Solutions. All Rights Reserved. -->
<LINK REL=STYLESHEET TYPE="text/css" HREF="AD_Styles-MAIN.css">
</HEAD>

<BODY>
<BR><TABLE WIDTH="100%" ALIGN=center BORDER=0><TBODY>
<TR><TD WIDTH=520><A ID="chapter"><IMG SRC="AD_Images/AD_Banner.jpg" WIDTH=520 HEIGHT=71></A>
<TR><TD WIDTH=520 HEIGHT=52 ALIGN=right VALIGN=top><P CLASS="IndentSans" ALIGN="Right">&#169; 2002-2007 Sonic Solutions<SUP>&#153;</SUP>. All Rights Reserved.</P></TD><TD>&nbsp;</TD></TR></TBODY></TABLE>
<P CLASS="Heading1"><A ID="Data Structures">5 &nbsp;Data Structures</A></P>
<P CLASS="IndentSerif">This chapter provides a reference to AuthorScript Advanced Data data structures in the following categories:</P>
<UL CLASS="IndentSerif_List"><LI><A HREF="#Structs">Structs</A></LI>
<LI><A HREF="#Errors">Errors</A></LI>
<LI><A HREF="#OS and Compiler Definitions">OS and Compiler Definitions</A></LI></UL>
<P CLASS="IndentSerif">Within each category, the objects are presented in alphabetical order. Syntax is shown in the left-hand column and description or comments are given on the right.<BR>
<BR>
<B><FONT COLOR="ff0000">!</FONT> NOTE</B>: This chapter lists all objects that are included in the header files of the AuthorScript AD SDK for which this documentation has been provided. These objects are not neccesarily all used by the current version of the SDK (refer to the function reference sections in <A HREF="AD_Guide_6.htm">Chapter 6</A> and <A HREF="AD_Guide_7.htm">Chapter 7</A>). Please contact your Sonic representative if you need additional information about the objects included in your version of the AuthorScript AD SDK.</P>

<HR SIZE=2 WIDTH="93%"><BR><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Structs">5.1 &nbsp;Structs</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section includes the following AuthorScript AD structs:</P>

<P CLASS="LinksList"><A HREF="#AS_File">AS_File</A>, <A HREF="#AS_File_Date">AS_File_Date</A>, <A HREF="#AS_StorageDevice">AS_StorageDevice</A>, <A HREF="#AS_String">AS_String</A>, <A HREF="#AS_Volume">AS_Volume</A></P>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>struct <B><A ID="AS_File">AS_File</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>{</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt16 Kind;</TD>
<TD>&#47;&#47; <B><A ID="File kind">File kind</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; File kind constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Kind File_IsFile = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Kind File_IsDir = (1 &lt;&lt; 1);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Kind File_IsRealTime = (1 &lt;&lt; 3);</TD>
<TD>&#47;&#47; Has some special limitations</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Property</TD>
<TD>&#47;&#47; <B><A ID="File property">File property</A></B><BR>
&#47;&#47; For AS_File_GetProperty, AS_Volume_GetEntryProperty, AS_File_SetProperty, and AS_Volume_SetEntryProperty</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_Name = 1,</TD>
<TD>&#47;&#47; IN&#47;OUT: File name IN as AS_File::Path, OUT as null-terminated UTF8 sequence of bytes</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_Size = 2,</TD>
<TD>&#47;&#47; OUT: file size in an 8byte UInt64</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_DateModified = 3,</TD>
<TD>&#47;&#47; IN&#47;OUT: Modification date of file as AS_Volume::DateTime</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_DateCreated = 4,</TD>
<TD>&#47;&#47; IN&#47;OUT: Creation date of file as AS_Volume::DateTime</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_LogicalBegin = 20,</TD>
<TD>&#47;&#47; OUT: LBA of file&#39;s first extent on disc</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_CgmsInfo = 21,</TD>
<TD>&#47;&#47; IN&#47;OUT: file&#39;s CGMS info as AS_File_CgmsInfo struct</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_CurrentPos = 22,</TD>
<TD>&#47;&#47; OUT: current file position</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_UdfPermissions = 23</TD>
<TD>&#47;&#47; IN&#47;OUT: UDF permissions on file or directory as UInt32</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Defaults:</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; file = OTHER_Read | GROUP_Read | OWNER_Read | OTHER_ChAttr | GROUP_ChAttr | OWNER_ChAttr</TD></TR>
<TR><TD>&nbsp</TD>
<TD>&#47;&#47; directory = OTHER_Read | GROUP_Read | OWNER_Read  | OTHER_ChAttr | GROUP_ChAttr | OWNER_ChAttr  | OTHER_Execute | GROUP_Execute | OWNER_Execute</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; <B>NOTE</B>: To set permissions for various OS, see section 3.3.3.3 (page 70) of UDF 2.6 specification (http:&#47;&#47;www.osta.org&#47;specs&#47;).</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; &#47;* Definitions: *&#47;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; &#47;* Bit for a File for a Directory *&#47;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; &#47;* Execute May execute file May search directory *&#47;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; &#47;* Write May change file contents May create and delete files *&#47;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; &#47;* Read May examine file contents May list files in directory *&#47;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; &#47;* ChAttr May change file attributes May change dir attributes *&#47;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; &#47;* Delete May delete file May delete directory *&#47;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Defines:</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OTHER_Execute 0x00000001</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OTHER_Write 0x00000002</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OTHER_Read 0x00000004</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OTHER_ChAttr 0x00000008</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OTHER_Delete 0x00000010</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define GROUP_Execute 0x00000020</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define GROUP_Write 0x00000040</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define GROUP_Read 0x00000080</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define GROUP_ChAttr 0x00000100</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define GROUP_Delete 0x00000200</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OWNER_Execute 0x00000400</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OWNER_Write 0x00000800</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OWNER_Read 0x00001000</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OWNER_ChAttr 0x00002000</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; #define OWNER_Delete 0x00004000</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; struct CgmsInfo</TD>
<TD>&#47;&#47; <B><A ID="CGMS info">CGMS info</A></B><BR>
&#47;&#47; See DVD-Video spec Part 2 (Version 1.03) section 3.6.4 for details about this structure</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 CGMSInformation;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 DataStructureType;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 ProtectionSystemInformation[4];</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum OpenMode</TD>
<TD>&#47;&#47; <B><A ID="Open mode">Open mode</A></B><BR>
&#47;&#47; File state for AS_Volume_OpenFile</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Closed = 0,</TD>
<TD>&#47;&#47; Only an output state</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Read = 1,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Append = 2</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 CreateFlags;</TD>
<TD>&#47;&#47; <B><A ID="Create flags">Create flags</A></B><BR>
&#47;&#47; For AS_Volume_CreateEntry, AS_Volume_CreateEntryFromHD, AS_Volume_CreateFileFromStream</TD></TR>
<TR><TD>&nbsp; &nbsp; static const CreateFlags Create_Parents = (1 &lt;&lt; 0);</TD>
<TD>&#47;&#47; create full path down to file</TD></TR>
<TR><TD>&nbsp; &nbsp; static const CreateFlags Create_Overwrite = (1 &lt;&lt; 1);</TD>
<TD>&#47;&#47; overwrites existing files</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 DeleteFlags;</TD>
<TD>&#47;&#47; <B><A ID="Delete flags">Delete flags</A></B><BR>
&#47;&#47; For AS_Volume_DeleteEntry</TD></TR>
<TR><TD>&nbsp; &nbsp; static const DeleteFlags Delete_Children = (1 &lt;&lt; 0);</TD>
<TD>&#47;&#47; If path is a directory, delete all children</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Handle;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef AS_String Path;</TD>
<TD>&#47;&#47; <B><A ID="File path">File path</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Count;</TD>
<TD>&#47;&#47; <B><A ID="File count">File count</A></B><BR>
&#47;&#47; Amounts to read and write, based on max RAM</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt64 Size;</TD>
<TD>&#47;&#47; <B><A ID="File size">File size</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; Handle myHandle;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>};</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>typedef struct <B><A ID="AS_File_Date">AS_File_Date</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>{</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; UInt16 year;</TD>
<TD>&#47;&#47; Year as an integer</TD></TR>
<TR><TD>&nbsp; &nbsp; UInt8 month;</TD>
<TD>&#47;&#47; Month from 1(Jan) to 12(Dec)</TD></TR>
<TR><TD>&nbsp; &nbsp; UInt8 day;</TD>
<TD>&#47;&#47; Day of month from 1 to 31</TD></TR>
<TR><TD>&nbsp; &nbsp; UInt8 hour;</TD>
<TD>&#47;&#47; Hour from 0 to 23</TD></TR>
<TR><TD>&nbsp; &nbsp; UInt8 minute;</TD>
<TD>&#47;&#47; Minute from 0 to 59</TD></TR>
<TR><TD>&nbsp; &nbsp; UInt8 second;</TD>
<TD>&#47;&#47; Second from 0 to 59</TD></TR>
<TR><TD>&nbsp; &nbsp; SInt8 zone;</TD>
<TD>&#47;&#47; Time offset from GMT in 30 minute increments</TD></TR>
<TR><TD>} AS_File_Date;</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>struct <B><A ID="AS_StorageDevice">AS_StorageDevice</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>{</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Handle;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Type;</TD>
<TD>&#47;&#47; <B><A ID="Storage device type">Storage device type</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; static const Type Type_Device = 0;</TD>
<TD>&#47;&#47; Storage device type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Type Type_File = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Type Type_Folder = (1 &lt;&lt; 2);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; Handle myHandle;</TD>
<TD>&#47;&#47; handle to device</TD></TR>
<TR><TD>&nbsp; &nbsp; Handle fileHandle;</TD>
<TD>&#47;&#47; handle to item in list of file device(s)</TD></TR>
<TR><TD>&nbsp; &nbsp; AS_String devicePath;</TD>
<TD>&#47;&#47; path to file device</TD></TR>
<TR><TD>&nbsp; &nbsp; AS_String deviceXMLOptionsPath;</TD>
<TD>&#47;&#47; optional XML file describing MovieDisc options or other options</TD></TR>
<TR><TD>&nbsp; &nbsp; Type deviceType;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Handle LastUsedDevice = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum TrayControls</TD>
<TD>&#47;&#47; <B><A ID="Tray controls">Tray controls</A></B><BR>
&#47;&#47; Types of tray control</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Tray_Control_Lock = 0,</TD>
<TD>&#47;&#47; prevent tray from moving</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Tray_Control_Unlock = 1,</TD>
<TD>&#47;&#47; allow tray to be ejected&#47;inserted</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Tray_Control_Open = 2,</TD>
<TD>&#47;&#47; asynchronous version of open tray</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Tray_Control_Close = 3,</TD>
<TD>&#47;&#47; asynchronous version of close tray</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Tray_Control_Open_Sync = 4,</TD>
<TD>&#47;&#47; synchronous version of open tray</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Tray_Control_Close_Sync = 5</TD>
<TD>&#47;&#47; synchronous version of close tray</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum DeviceState</TD>
<TD>&#47;&#47; <B><A ID="Device state">Device state</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; &#47;&#47;State_InUse = 1, </TD>
<TD>&#47;&#47; Device in use by another application.<BR>
&#47;&#47; <B>NOTE</B>: not reported back from engine, not applicable for embedded applications</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; State_Not_Ready = 70,</TD>
<TD>&#47;&#47; generally no media in device</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; State_Ready = 17,</TD>
<TD>&#47;&#47; device is ready</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; State_Becoming_Ready = 71</TD>
<TD>&#47;&#47; device is busy</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Erase_Type</TD>
<TD>&#47;&#47; <B><A ID="Erase type">Erase type</A></B><BR>
&#47;&#47; types of erase</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Quick_Erase = 0,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Long_Erase = 1</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef wchar_t* UnicodeString;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 TrayStatus_Type;</TD>
<TD>&#47;&#47; <B><A ID="Tray status type">Tray status type</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Tray status type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrayStatus_Type TrayStatus_Unknown = 1;</TD>
<TD>&#47;&#47; unknown status</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrayStatus_Type TrayStatus_Open = 2;</TD>
<TD>&#47;&#47; tray is open</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrayStatus_Type TrayStatus_Closed = 3;</TD>
<TD>&#47;&#47; tray is closed</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Scan_Flags;</TD>
<TD>&#47;&#47; <B><A ID="Scan flags">Scan flags</A></B><BR>
&#47;&#47; Device scan type passed in to AS_GetStorageDeviceCount</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Scan_Flags Scan_All = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Scan_Flags Scan_Optical = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Scan_Flags Scan_Tape = (1 &lt;&lt; 1);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Bus_Kind;</TD>
<TD>&#47;&#47; <B><A ID="Bus Kind">Bus Kind</A></B><BR>
</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef struct</TD>
<TD>&#47;&#47; <B><A ID="Bus Info">Bus Info</A></B> query properties</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Bus_Kind bus_kind;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 addr_valid;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 addr_adapter_id;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 addr_target_id;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 addr_lun_id;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 Reserved[128];</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; } Bus_Info;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Bus kind constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Bus_Kind Bus_ATAPI = 25;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Bus_Kind Bus_SCSI = 26;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Bus_Kind Bus_USB = 28;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Bus_Kind Bus_USB2 = 31;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Bus_Kind Bus_1394 = 32;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Bus_Kind Bus_Unknown = 0xfffffff;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Authentication_Type;</TD>
<TD>&#47;&#47; <B><A ID="Authentication type">Authentication type</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; Authentication query properties</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Authentication_Type Authentication_None = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Authentication_Type Authentication_CPPM = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Authentication_Type Authentication_CPRM = (1 &lt;&lt; 1);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Authentication_Type Authentication_AACS = (1 &lt;&lt; 2);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 DevType;</TD>
<TD>&#47;&#47; <B><A ID="Device type">Device type</A></B><BR>
&#47;&#47; Query properties</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Device type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const DevType IsFile = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const DevType IsOptical = (1 &lt;&lt; 1);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const DevType IsTape = (1 &lt;&lt; 2);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum DevProp_Type</TD>
<TD>&#47;&#47; <B><A ID="Device property type">Device property type</A></B><BR>
&#47;&#47; query device properties</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_Description = 0,</TD>
<TD>&#47;&#47;UnicodeString OUT: string of Device Description</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_MakeName = 1,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_ModelName = 2,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_Version = 3,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_DrivePath = 6,</TD>
<TD>&#47;&#47;UnicodeString OUT: string of Device Drive Letter</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_DevType = 7,</TD>
<TD>&#47;&#47;DevType OUT: bits of the device type (IsTape, IsOptical, IsFile)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_MedTypesCapable = 11,</TD>
<TD>&#47;&#47;MediaKind OUT: bits of media types supported (DVD-RW, DVD+RW, CD-RW, CD-R, etc)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_TrayStatus = 12,</TD>
<TD>&#47;&#47;TrayStatus_Type OUT: TrayStatus type (UInt32)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_Bus_Info = 17,</TD>
<TD>&#47;&#47;Bus_Info OUT: structure describes bus kind and adapter&#47;target&#47;lun</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_AuthenTypes = 0x30004,</TD>
<TD>&#47;&#47;Authentication_Type OUT: UInt32</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_SerialNum = 0x30005,</TD>
<TD>&#47;&#47;SerialNum OUT: UInt8[16 bytes max]</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_CopyProtection = 0x30006,</TD>
<TD>&#47;&#47;ProtectionType OUT: bitflag of CSS and CopyBlock types supported</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; DevProp_MaxTransferSize = 18</TD>
<TD>&#47;&#47;UInt32 OUT: size in bytes of max tranfer size of device</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt64 MediaKind;</TD>
<TD>&#47;&#47; <B><A ID="Media kind">Media kind</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; Media kind constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsCdRom = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsCdr = (1 &lt;&lt; 1);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsCdrw = (1 &lt;&lt; 2);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDdCdrom = (1 &lt;&lt; 3);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDdCdr = (1 &lt;&lt; 4);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDdCdrw = (1 &lt;&lt; 5);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdRom = (1 &lt;&lt; 6);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdr = (1 &lt;&lt; 7);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdrw = (1 &lt;&lt; 8);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdpr = (1 &lt;&lt; 9);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdprw = (1 &lt;&lt; 10);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdRam = (1 &lt;&lt; 11);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdpr9 = (1 &lt;&lt; 12);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsDvdr9 = (1 &lt;&lt; 13);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsBdr = (1 &lt;&lt; 14);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsBdre = (1 &lt;&lt; 15);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsHdDvdRom = (1 &lt;&lt; 16);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsHdDvdr = (1 &lt;&lt; 17);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsHdDvdrw = (1 &lt;&lt; 18);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsBdrom = (1 &lt;&lt; 19);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaKind MediaIsSeqTape = ((UInt64)1 &lt;&lt; 31);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; <B><A ID="Media state">Media state</A></B><BR>
&#47;&#47; <B>NOTES</B>:<BR>
&#47;&#47; Media State Information is valid only if Device state reports ready<BR>
&#47;&#47; Incompatible media is represented by the following states: Readable = false, Writable = false</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; Media state constants</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 MediaState;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsReadable = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsWritable = (1 &lt;&lt; 1);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsInvisible = (1 &lt;&lt; 2);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsAppendable = (1 &lt;&lt; 3);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsRewritable = (1 &lt;&lt; 5);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsErasable = (1 &lt;&lt; 7);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsProtected = (1 &lt;&lt; 10);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState MediaIsBlank = (1 &lt;&lt; 12);</TD>
<TD>&#47;&#47; See notes above</TD></TR>
<TR><TD>&nbsp; &nbsp; static const MediaState LayerJumpSettable = (1 &lt;&lt; 13);</TD>
<TD>&#47;&#47; report whether setting jump address is allowed</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 SpeedSetting_Type;</TD>
<TD>&#47;&#47; <B><A ID="Speed setting type">Speed setting type</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Speed setting type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const SpeedSetting_Type Speed_Min = 0;</TD>
<TD>&#47;&#47; minimum speed</TD></TR>
<TR><TD>&nbsp; &nbsp; static const SpeedSetting_Type Speed_Max = 0xffffffff;</TD>
<TD>&#47;&#47; maximum speed</TD></TR>
<TR><TD>&nbsp; &nbsp; static const SpeedSetting_Type Speed_Var = 0xfffffffe;</TD>
<TD>&#47;&#47; variable speed</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 ProtectionType;</TD>
<TD>&#47;&#47; <B><A ID="Protection type">Protection type</A></B><BR>
&#47;&#47; returned during query of DevProp_CopyProtection and MedProp_CopyProtection</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Protection type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const ProtectionType ProtectionType_None = 0;</TD>
<TD>&#47;&#47; drive&#47;media offers no copy protection</TD></TR>
<TR><TD>&nbsp; &nbsp; static const ProtectionType ProtectionType_MovieDisc_CSS = (1 &lt;&lt; 0);</TD>
<TD>&#47;&#47; drive&#47;media offers MovieDisc CSS protection.</TD></TR>
<TR><TD>&nbsp; &nbsp; static const ProtectionType ProtectionType_CopyBlock_BadECC = (1 &lt;&lt; 16);</TD>
<TD>&#47;&#47; drive&#47;media offers CopyBlock &quot;Bad ECC blocks&quot;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 FileFormatType;</TD>
<TD>&#47;&#47; <B><A ID="File format type">File format type</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; File type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FileFormatType FormatType_Unknown = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FileFormatType FormatType_Raw = 1;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FileFormatType FormatType_OpticalDetect = 2;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FileFormatType FormatType_Raw_2048 = 3;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FileFormatType FormatType_Raw_2336 = 4;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FileFormatType FormatType_Raw_2352 = 5;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FileFormatType FormatType_GI = 6;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum MediaProp_Type</TD>
<TD>&#47;&#47; <B><A ID="Media property type">Media property type</A></B><BR>
&#47;&#47; Query media properties are valid if the device state is State_Ready</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_Num_Sessions = 3,</TD>
<TD>&#47;&#47; UInt32 OUT: number of sessions</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_Num_Tracks = 4,</TD>
<TD>&#47;&#47; UInt32 OUT: number of tracks</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_Num_Layers = 5,</TD>
<TD>&#47;&#47; UInt32 OUT: 2 = dual layer, 1 = single layer</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_MaxLayerJumpAddr = 8,</TD>
<TD>&#47;&#47; UInt64 OUT: location of max layer jump address</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_State = 12,</TD>
<TD>&#47;&#47; MediaState OUT: State of media (writable, write-protected, etc).</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_Bytes_Used = 18,</TD>
<TD>&#47;&#47; UInt64 OUT: Media space used</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_Bytes_Free = 19,</TD>
<TD>&#47;&#47; UInt64 OUT: Media Capacity information </TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_Kind = 30,</TD>
<TD>&#47;&#47; MediaKind OUT: DVD-RW, DVD+RW, CD-RW, CD-R, etc</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_FileFormat = 31,</TD>
<TD>&#47;&#47; FileFormat IN&#47;OUT: File Device format type</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_CurRead_DataRates = 23,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: KBps for the current read speed</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_CurWrite_DataRates = 24,</TD>
<TD>&#47;&#47; UInt32 OUT: KBps for the current write speed</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_WriteList_DataRates = 26,</TD>
<TD>&#47;&#47; UInt32[] OUT: The list of UInt32s of Write Data rates</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_LayerJumpAddr = 37,</TD>
<TD>&#47;&#47; UInt64 IN&#47;OUT: location of layer jump address</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_MinLayerJumpAddr = 45,</TD>
<TD>&#47;&#47; UInt64 OUT: location of min layer jump address</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_CurRead_Hundredth_X =0x00010000,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: 1&#47;100ths X for current read speed
</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_CurWrite_Hundredth_X =0x00010001,</TD>
<TD>&#47;&#47; UInt32 OUT: 1&#47;100ths X for current write speed</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_WriteList_Hundredth_X =0x00010003,</TD>
<TD>&#47;&#47; UInt32[] OUT: The list of UInt32s of Data rates in 1&#47;100ths X</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_CurAuthenType =0x00030004,</TD>
<TD>&#47;&#47; Authentication_Type IN: get the authentication type of the media</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_CopyProtection =0x00030006,</TD>
<TD>&#47;&#47; ProtectionType OUT: bitflag of ProtectionType supported by this media.</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; MedProp_TestWrite = 99</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: Testwrite enabled (1) &#47; disabled (0) - (reports invalid media if no media support).<BR>
&#47;&#47; ignored for RTTD mode</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 TrackProp_TrackType;&nbsp; &nbsp; </TD>
<TD>&#47;&#47; <B><A ID="Track type">Track type</A></B><BR>
&#47;&#47; query track properties</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; Track type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_TrackType TrackType_Audio = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_TrackType TrackType_Data = 1;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_TrackType TrackType_DataMode2 = 2;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_TrackType TrackType_Blank = 69;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 TrackProp_RecordMode_Type;</TD>
<TD>&#47;&#47; <B><A ID="Track record mode type">Track record mode type</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Record mode type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_None = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_TAO = 1;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_SAO = 2;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_FixedPacket = 3;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_VarPacket = 4;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_Incremental= 5;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_RestrictOvr = 6;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_Standard = 7;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_SAO_Finalize = 8;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_LayerJump = 9;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_POW = 10;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_RecordMode_Type TrackMode_Incremental_Borderless = 11;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 TrackProp_IOState;</TD>
<TD>&#47;&#47; <B><A ID="Track IO state">Track IO state</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Track IO state constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Writable = 0x00000002;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Invisible = 0x00000004;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Appendable = 0x00000008;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Open = 0x00000010;</TD>
<TD>&#47;&#47; equivalent to appendable except for RO</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Rewritable = 0x00000020;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_AutoJump = 0x00000040;</TD>
<TD>&#47;&#47; note : different from media state</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Erasable = 0x00000080;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Formattable = 0x00000100;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Expandable = 0x00000800;</TD>
<TD>&#47;&#47; note : different from media state</TD></TR>
<TR><TD>&nbsp; &nbsp; static const TrackProp_IOState Track_IOState_Blank = 0x00001000;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum TrackProp_Type</TD>
<TD>&#47;&#47; <B><A ID="Track property type">Track property type</A></B><BR>
&#47;&#47; Track properties are valid if the device state is State_Ready</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_BlockSize = 1,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: blocksize in bytes (only tape can select new blocksize)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_WriteFrameSize = 2,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: frame size for write</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_OptimalFrameSize = 3,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: optimal frame size for write</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_TrkType = 4,</TD>
<TD>&#47;&#47; TrackProp_TrackType IN&#47;OUT: type of track (audio, data, data Mode2, blank)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_RecordMode = 5,</TD>
<TD>&#47;&#47; TrackProp_RecordMode_Type IN&#47;OUT: recording mode</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_SessionNum = 6,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: session number</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_StartAddr = 7,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: start address of track</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_Length = 8,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: length of track</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_RecLength = 9,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: recorded length of track</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_AppendAddr =10,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: append address of track</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_State =11,</TD>
<TD>&#47;&#47; TrackProp_IOState IN&#47;OUT: state of track</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CurFormatType =12,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: currently formatted type of track</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_FormatTypes =13,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: format types for tracks</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_Copyrighted =14,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: copyrighted</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_Pregap =15,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: size of pregap (in blocks)</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; cdtext</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_ISRC =16,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText ISRC</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_Title =17,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText title</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_Performer =18,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText Performer</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_Songwriter =19,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText Songwriter</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_Composer =20,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText Composer</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_Arranger =21,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText Arranger</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_Message =22,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText Message</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_NumExtents =23,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: number of extents in track</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_Postgap =24,</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: size of postgap (in blocks)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_Genre =25,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText Genre</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_CDText_GenreCode =26,</TD>
<TD>&#47;&#47; UnicodeString IN&#47;OUT: string of CDText Genre Code</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; TrackProp_LastRecAddr =27</TD>
<TD>&#47;&#47; UInt32 IN&#47;OUT: last recorded address</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum ExclusiveAccess_Type</TD>
<TD>&#47;&#47; <B><A ID="Exclusive access">Exclusive access</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&#47; Exclusive access constants</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; ExclusiveAccess_Obtain = 1,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; ExclusiveAccess_Quick_Obtain = 2,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; ExclusiveAccess_Release = 3,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; ExclusiveAccess_Query = 4</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum SetCallbackType</TD>
<TD>&#47;&#47; <B><A ID="Callback type">Callback type</A></B><BR>
&#47;&#47; Registration for device arrival&#47;departure notification</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Callback_Register = 1,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Callback_Unregister = 2</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Event_Type</TD>
<TD>&#47;&#47; <B><A ID="Event type">Event type</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; EventMediaRemoval = 1,</TD>
<TD>&#47;&#47; media disappeared</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; EventMediaArrival = 2,</TD>
<TD>&#47;&#47; new media or changed media is ready</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; EventDeviceArrival = 6,</TD>
<TD>&#47;&#47; drive appeared</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; EventDeviceRemoval = 7</TD>
<TD>&#47;&#47; drive disappeared</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Info</TD>
<TD>&#47;&#47; <B><A ID="Callback info">Callback info</A></B> types</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Info_ProgressUpdate = 1,</TD>
<TD>&#47;&#47; infoDword = percent complete, infoPtr = Progress structure</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Info_PromptForMediaInDevice = 2,</TD>
<TD>&#47;&#47; infoDword = unused, infoPtr = unused</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; struct Progress</TD>
<TD>&#47;&#47; <B><A ID="Progress info">Progress info</A></B><BR>
&#47;&#47; additional progress info (beyond percent complete)</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 ValidBytes;</TD>
<TD>&#47;&#47; size, in bytes, that follow that are valid</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; so this structure can be expanded to return additional</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; information in the future</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 CurrentSector;</TD>
<TD>&#47;&#47; How many sectors have been written (not the actual current</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; sector number)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 TotalSectors;</TD>
<TD>&#47;&#47; total number of sectors</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 DeviceInfo;</TD>
<TD>&#47;&#47; returns media handle on which this progress is reported</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 ProgressStatus;</TD>
<TD>&#47;&#47; reserved for future use</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 CurrentOperation;</TD>
<TD>&#47;&#47; reserved for future use</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; progress consts for detailed callback info</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 JobType;</TD>
<TD>&#47;&#47; <B><A ID="Job type">Job type</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; Job type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Writing = 0x00000003;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Reading = 0x00000004;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Comparing = 0x00000005;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Formatting = 0x00000006;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Erasing = 0x00000007;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Initializing = 0x00000008;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Finalizing = 0x00000009;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Aborting = 0x0000000a;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_WriteFilemark = 0x0000000b;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobType JobType_Seek = 0x0000000c;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 JobStatus;</TD>
<TD>&#47;&#47; <B><A ID="Job status">Job status</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Job status constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobStatus JobStatus_Success = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobStatus JobStatus_Running = 1;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobStatus JobStatus_BusyAborting = 2;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobStatus JobStatus_Idle = 0x10000;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobStatus JobStatus_PartialSuccess = 0x20000 | 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobStatus JobStatus_Aborted = ( 0x20000 | 0x0006);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const JobStatus JobStatus_Error = 0xfffe0000;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 CopyFlags;</TD>
<TD>&#47;&#47; <B><A ID="Copy flags">Copy flags</A></B></TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Copy flag constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const CopyFlags CopyFlags_Write = 1;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const CopyFlags CopyFlags_TestMode = 2;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const CopyFlags CopyFlags_Compare = 3;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const CopyFlags CopyFlags_CompareData = 4;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const CopyFlags CopyFlags_VerifylessWrite = 5;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; <B><A ID="Device information callback">Device information callback</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; typedef AS_StorageError (AS_CALLBACK *InfoCallback)(</TD>
<TD>&#47;&#47; Function typedef for reporting progress or other information<BR>
&#47;&#47; Used in AS_StorageDevice_EraseMedia and other device functions taking callback parameter</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; const Info& info,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 infoDword, void *infoPtr,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; void *callerUse);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; <B><A ID="Event callback">Event callback</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; typedef void (AS_CALLBACK * EventCallback)(</TD>
<TD>&#47;&#47; Function typedef for receiving device event information<BR>
&#47;&#47; Used to alert client of device&#47;media presence.</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; enum Event_Type Event,</TD>
<TD>&#47;&#47; Event: device arrival, device departure (see <A HREF="#Event type">Event type</A>).</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Handle Device,</TD>
<TD>&#47;&#47; Handle to device in which the event occurred.</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; void* CallerUse);</TD>
<TD>&#47;&#47; Caller gets their PVOID back that they registered with.</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef struct</TD>
<TD>&#47;&#47; <B><A ID="Device error">Device error</A></B><BR>
&#47;&#47; reported by AS_StorageDevice_GetError</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 valid;</TD>
<TD>&#47;&#47; valid bit represents the following information is valid. once queried the the valid bit shall be reset</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 cmd;</TD>
<TD>&#47;&#47; These four bytes may be reported to Sonic for further information on the error</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 key;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 code;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 qual;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt8 other[16];</TD>
<TD>&#47;&#47; This may be dumped to a log file for more detail on the error</TD></TR>
<TR><TD>&nbsp; &nbsp; } Error;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>};</TD>
<TD>&#47;&#47; internal representation of the device.</TD></TR></TBODY></TABLE>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>struct <B><A ID="AS_String">AS_String</A></B></TD>
<TD>&#47;&#47; Generic string type to pass to AuthorScript AD functions.</TD></TR>
<TR><TD>{</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Type</TD>
<TD>&#47;&#47;  <B><A ID="String encoding type">String encoding type</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Type_ASCII = 1,</TD>
<TD>&#47;&#47; ASCII (7-bit, high ASCII characters not allowed).<BR>
&#47;&#47; <B>NOTE</B>: Use this type only if you are certain the string cannot contain any characters that are not in the 7-bit ASCII character set.</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Type_UTF8 = 2,</TD>
<TD>&#47;&#47; Unicode UTF-8 (8-bit).<BR>
&#47;&#47; <B>NOTES</B>: May contain any Unicode character and is a consistent string cross-platform. <BR>
&#47;&#47; You must ensure you are using the correct locale&#47;code page to convert or display this string type.<BR>
&#47;&#47; This type is useful for strings that are saved to a file intended to be compatible cross-platform.<BR>
&#47;&#47; A single Unicode code point is a variable length of 1 to 4 bytes.</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; Type_Wide = 3,</TD>
<TD>&#47;&#47; Unicode wchar_t (Platform dependant, UTF-16LE on Windows Intel, typically UTF32(LE or BE) on other platforms).<BR>
&#47;&#47; <B>NOTES</B>: This can contain any Unicode character in a wchar_t type.<BR>
&#47;&#47; The Unicode type depends on the platform your program is compiled for (could be UTF-16LE, UTF-16BE, UTF-32LE, or UTF-32BE), but it is useful because C has calls to natively use wchar_t type regardless of the current local&#47;code page.<BR>
&#47;&#47; If you intend to share this string cross-platform, be aware of the character set used for this type :<BR>
&#47;&#47; For UTF-32, a single Unicode code point is always 4 bytes.<BR>
&#47;&#47; For UTF-16, a single Unicode code point is either 2 or 4 bytes.<BR>
&#47;&#47; See www.unicode.org for more details on Unicode character encoding.</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; Type type;</TD>
<TD>&#47;&#47; encoding type</TD></TR>
<TR><TD>&nbsp; &nbsp; size_t size;</TD>
<TD>&#47;&#47; size of string data buffer in characters</TD></TR>
<TR><TD>&nbsp; &nbsp; void * data;</TD>
<TD>&#47;&#47; pointer to string data buffer</TD></TR>
<TR><TD>};</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>struct <B><A ID="AS_Volume">AS_Volume</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>{</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Handle;</TD>
<TD>&#47;&#47; Volume handle for handles to internal objects</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Property</TD>
<TD>&#47;&#47; <B><A ID="Volume property">Volume property</A></B><BR>
&#47;&#47; Used for AS_Volume_GetProperty and AS_Volume_SetProperty</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_FS_Type = 1,</TD>
<TD>&#47;&#47; OUT: AS_Volume::FS_Type</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_Format_Type = 2,</TD>
<TD>&#47;&#47; OUT: AS_Volume::Format_Type</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_State = 3,</TD>
<TD>&#47;&#47; OUT: AS_Volume_State - return error if not existent</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_Name = 4,</TD>
<TD>&#47;&#47; IN&#47;OUT: Volume name IN as AS_File::Path, OUT as null-terminated UTF8 sequence of bytes</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_BlockSize = 5,</TD>
<TD>&#47;&#47; OUT: Block size of the volume in a 4byte UInt32</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_FreeBlocks = 6,</TD>
<TD>&#47;&#47; OUT: Volume free blocks in a 4byte UInt32</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_DateModified = 7,</TD>
<TD>&#47;&#47; IN&#47;OUT: Modification date of volume as AS_Volume::DateTime</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_DateCreated = 8,</TD>
<TD>&#47;&#47; IN&#47;OUT: Creation date of volume as AS_Volume::DateTime</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_Delimiter = 9,</TD>
<TD>&#47;&#47; IN&#47;OUT: Delimiter used for paths on media as SInt8</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_ApplicationID = 10,</TD>
<TD>&#47;&#47; IN&#47;OUT: Application ID IN as AS_File::Path, OUT as null-terminated UTF8 sequence of bytes</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_FastWrite = 11,</TD>
<TD>&#47;&#47; IN: Write data in fast write mode (no read-after-write) as UInt32 0 = off, 1 = on</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_NumFiles = 12,</TD>
<TD>&#47;&#47; OUT: UInt32 number of files currently on volume</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_NumFolders = 13,</TD>
<TD>&#47;&#47; OUT: UInt32 number of folders currently on volume</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Prop_RESERVED_01 = 256</TD>
<TD>&#47;&#47; RESERVED FOR INTERNAL USE ONLY</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 FS_Type;</TD>
<TD>&#47;&#47; <B><A ID="File system type">File system type</A></B><BR>
&#47;&#47; OUT from AS_StorageDevice_OpenVolume; IN to AS_Volume_Create</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; File system type constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_None = 0;</TD>
<TD>&#47;&#47; OUT: No existing file system</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_Default = (1 &lt;&lt; 0);</TD>
<TD>&#47;&#47; IN: No file system specified. Use default.</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_ISO_Level_1 = (1 &lt;&lt; 1);</TD>
<TD>&#47;&#47; IN&#47;OUT: ISO 9660 Level 1</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_ISO_Level_2 = (1 &lt;&lt; 2);</TD>
<TD>&#47;&#47; IN&#47;OUT: ISO 9660 Level 2</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_ISO_Level_2_Long = (1 &lt;&lt; 3);</TD>
<TD>&#47;&#47; IN&#47;OUT: ISO 9660 Level 2 with long names and any valid ANSI char</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_ISO_Versionless = (1 &lt;&lt; 4);</TD>
<TD>&#47;&#47; IN&#47;OUT: ISO 9660 No Version</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_Joliet = (1 &lt;&lt; 5);</TD>
<TD>&#47;&#47; IN&#47;OUT: Joliet</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_UDF102 = (1 &lt;&lt; 10);</TD>
<TD>&#47;&#47; IN&#47;OUT: UDF 1.02</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_UDF15 = (1 &lt;&lt; 11);</TD>
<TD>&#47;&#47; IN&#47;OUT: UDF 1.5</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_UDF2 = (1 &lt;&lt; 12);</TD>
<TD>&#47;&#47; IN&#47;OUT: UDF 2.0</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_UDF25 = (1 &lt;&lt; 13);</TD>
<TD>&#47;&#47; IN&#47;OUT: UDF 2.5</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_UDF26 = (1 &lt;&lt; 14);</TD>
<TD>&#47;&#47; IN&#47;OUT: UDF 2.6</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_Audio = (1 &lt;&lt; 21);</TD>
<TD>&#47;&#47; IN&#47;OUT: Audio</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_TDF = (1 &lt;&lt; 25);</TD>
<TD>&#47;&#47; OUT: custom interleaved format</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_VRT = (1 &lt;&lt; 26);</TD>
<TD>&#47;&#47; OUT: custom video format</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_ISO = FS_ISO_Level_1;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const FS_Type FS_Bridge = FS_ISO | FS_UDF102;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Format_Type</TD>
<TD>&#47;&#47; <B><A ID="Format Type">Format Type</A></B><BR>
&#47;&#47; High-level format types</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_Unknown = 0,</TD>
<TD>&#47;&#47; no known high-level format type detected</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_Data = 1,</TD>
<TD>&#47;&#47; Joliet&#47;ISO on CD media, UDF 1.02&#47;ISO on DVD media, UDF 2.0 on -RAM, UDF 2.5 on BD&#47;HD, 2.6 on BDR</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_AudioCD = 2,</TD>
<TD>&#47;&#47; Audio CD Layout (not for Scenarist)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_VCD = 3,</TD>
<TD>&#47;&#47; VCD 2.0 Layout (nfS)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_SVCD = 4,</TD>
<TD>&#47;&#47; SVCD (nfS)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_DVD = 5,</TD>
<TD>&#47;&#47; VIDEO_TS Layout with UDF 1.02</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_DVDPlusVR = 6,</TD>
<TD>&#47;&#47; UDF 1.02 (nfS)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_DVDDashVR = 7,</TD>
<TD>&#47;&#47; UDF 2.0 (nfS)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_VRT = 8,</TD>
<TD>&#47;&#47; UDF 1.02 &#47; TMP_VMGI if not closed (nfS)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_BDAV = 9,</TD>
<TD>&#47;&#47; BDAVn Layout (UDF 2.5 on BD-RE or 2.6 on BD-R)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_BDMV = 10,</TD>
<TD>&#47;&#47; BDROM</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_HDDVD = 11,</TD>
<TD>&#47;&#47; HD DVD (UDF 2.5) - YES for Scenarist -&gt; </TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_DDP20 = 12,</TD>
<TD>&#47;&#47; VIDEO_TS in an image file + DDP 2.0 files (yfS)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_DDP21 = 13,</TD>
<TD>&#47;&#47; VIDEO_TS in an image file + DDP 2.1 files (???)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_DDP30 = 14,</TD>
<TD>&#47;&#47; HVDVD_TS in an image file + DDP 3.0 files</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_CMF = 15,</TD>
<TD>&#47;&#47; HVDVD_TS in an image file + CMF files</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&#47;&#47; Aliases</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Type_MP3 = Type_Data</TD>
<TD>&#47;&#47; MP3 CD</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 AccessFlag;</TD>
<TD>&#47;&#47; <B><A ID="Access flag">Access flag</A></B><BR>
&#47;&#47; Specified with AS_Volume_Mount and AS_Volume_Format</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Volume access constants (mutually-exclusive)</TD></TR>
<TR><TD>&nbsp; &nbsp; static const AccessFlag ReadOnly = (1 &lt;&lt; 0);</TD>
<TD>&#47;&#47; IN: for AS_Volume_Mount; writing not allowed</TD></TR>
<TR><TD>&nbsp; &nbsp; static const AccessFlag Mastering = (1 &lt;&lt; 1);</TD>
<TD>&#47;&#47; IN: for AS_Volume_Create, AS_Volume_Mount; AS_File_Write not allowed</TD></TR>
<TR><TD>&nbsp; &nbsp; static const AccessFlag RTTD = (1 &lt;&lt; 2);</TD>
<TD>&#47;&#47; IN: for AS_Volume_Create, AS_Volume_Mount; real-time to disc, allows AS_File_Write</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 State;</TD>
<TD>&#47;&#47; <B><A ID="Volume state">Volume state</A></B><BR>
&#47;&#47; Returned from AS_Volume_GetProperty</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Volume state constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const State File_IsMounted = (1 &lt;&lt; 0);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const State File_IsDirty = (1 &lt;&lt; 1);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; static const State File_IsAppendable = (1 &lt;&lt; 2);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum Flush_Border_Options</TD>
<TD>&#47;&#47; <B><A ID="Flush border options">Flush border options</A></B><BR>
&#47;&#47; Passed into AS_Volume_Flush<BR>
&#47;&#47; <B>NOTE</B>: Caller is REQUIRED to specify one of these mutually exclusive options)</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Border_Open = 1,</TD>
<TD>&#47;&#47; does not write any border</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Border_Close = 2,</TD>
<TD>&#47;&#47; writes border and leaves disc appendable</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Border_Final = 3</TD>
<TD>&#47;&#47; finalizes write-once media (making it read-only)</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 Flush_Flags;</TD>
<TD>&#47;&#47; <B><A ID="Flush flags">Flush flags</A></B><BR>
&#47;&#47; flags passed into AS_Volume_Flush</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; Flush flag constants</TD></TR>
<TR><TD>&nbsp; &nbsp; static const Flush_Flags Flush_Verify = (1 &lt;&lt; 0);</TD>
<TD>&#47;&#47; does verify after write</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; enum BootType</TD>
<TD>&#47;&#47; <B><A ID="Boot type">Boot type</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_None = 0,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_Floppy12 = 1,</TD>
<TD>&#47;&#47; for 1.2 floppy images</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_Floppy144 = 2,</TD>
<TD>&#47;&#47; for 1.44 floppy images</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_Floppy288 = 3,</TD>
<TD>&#47;&#47; for 2.88 floppy images</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_HD = 4,</TD>
<TD>&#47;&#47; for Hard Drive images</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_NoEmulation = 5,</TD>
<TD>&#47;&#47; for a special boot image</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_NoEmulationWithBootInfoTable = 6,</TD>
<TD>&#47;&#47;for a special boot image; also writes Boot Info table </TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Boot_LoadLast = 7</TD>
<TD>&#47;&#47; load the previous boot image</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; Handle myHandle;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef UInt32 (AS_CALLBACK * StreamCallback)(</TD>
<TD>&#47;&#47; <B><A ID="Stream callback">Stream callback</A></B><BR>
&#47;&#47; Function typedef for streaming callback function used in AS_Volume_CreateFileFromStream.<BR>
&#47;&#47; <B>NOTE</B>: This function will be called repeatedly until all file data has been read.</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  SInt64 pos,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  SInt8 * pBuffer,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  SInt32 bytesRequested,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  SInt32 * pBytesGiven,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD> &nbsp; &nbsp; &nbsp; &nbsp;  void * callerUse);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&#47;&#47; <B><A ID="Volume progress">Volume progress</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; enum Info</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Info_ProgressUpdate = 1,</TD>
<TD>&#47;&#47; infoDword = percent complete, infoPtr = Progress structure</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Info_PromptForMediaInDevice = 2,</TD>
<TD>&#47;&#47; infoDword = unused, infoPtr = unused</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  Info_PromptForNextMedia = 3</TD>
<TD>&#47;&#47; infoDword = unused, infoPtr = unused</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; struct Progress</TD>
<TD>&#47;&#47; additional progress info (beyond percent complete)</TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt32 ValidBytes;</TD>
<TD>&#47;&#47; size, in bytes, that follow that are valid so this structure can be expanded to return additional information in the future</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt32 CurrentSector;</TD>
<TD>&#47;&#47; How many sectors have been written (not the actual current sector number)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt32 TotalSectors;</TD>
<TD>&#47;&#47; Question: should we return this every time, or should this be a property?</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; </TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef AS_StorageError (AS_CALLBACK *InfoCallback)(</TD>
<TD>&#47;&#47; <B><A ID="Volume information callback">Volume information callback</A></B><BR>
&#47;&#47; Function typedef for reporting progress information<BR>
&#47;&#47; Used in AS_Volume_Mount, and AS_Volume_Flush</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; const Info& info,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; UInt32 infoDword,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; void *infoPtr,</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp; void *callerUse);</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; typedef struct DateTime</TD>
<TD>&#47;&#47; <B><A ID="Date time">Date time</A></B></TD></TR>
<TR><TD>&nbsp; &nbsp; {</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt16 year;</TD>
<TD>&#47;&#47; Year as an integer</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 month;</TD>
<TD>&#47;&#47; Month from 1(Jan) to 12(Dec)</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 day;</TD>
<TD>&#47;&#47; Day of month from 1 to 31</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 hour;</TD>
<TD>&#47;&#47; Hour from 0 to 23</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 minute;</TD>
<TD>&#47;&#47; Minute from 0 to 59</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  UInt8 second;</TD>
<TD>&#47;&#47; Second from 0 to 59</TD></TR>
<TR><TD>&nbsp; &nbsp; &nbsp; &nbsp;  SInt8 zone;</TD>
<TD>&#47;&#47; Time offset from GMT in 30 minute increments</TD></TR>
<TR><TD>&nbsp; &nbsp; };</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>};</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<HR SIZE=2 WIDTH="93%"><BR><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Errors">5.2 &nbsp;Errors</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section contains definitions related to AuthorScript AD errors:</P>

<P CLASS="LinksList"><A HREF="#General API errors">General API errors</A>, <A HREF="#API verification errors">API verification errors</A>, <A HREF="#Device and Media Errors">Device and Media Errors</A>, <A HREF="#File Handling errors">File Handling errors</A>, <A HREF="#Metadata verification errors">Metadata verification errors</A>, <A HREF="#Cancel error code">Cancel error code</A>, <A HREF="#Verify errors">Verify errors</A></P>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>typedef SInt32 <B><A ID="AS_StorageError">AS_StorageError</A></B>;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="Error code constants">Error code constants</A></B></TD>
<TD><B></B></TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_Base = -97000;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_None = 0;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="General API errors">General API errors</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_BufferOverflow = AS_StorageError_Base - 10;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_Fatal = AS_StorageError_Base - 11;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_NotFound = AS_StorageError_Base - 12;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_NotImplemented = AS_StorageError_Base - 13;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_NotInitialized = AS_StorageError_Base - 14;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_NotSupported = AS_StorageError_Base - 15;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_UnsupportedVersion = AS_StorageError_Base - 16;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidAccess = AS_StorageError_Base - 17;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_ReentrantCall = AS_StorageError_Base - 18;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="API verification errors">API verification errors</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidFile = AS_StorageError_Base - 30;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidFolder = AS_StorageError_Base - 31;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidIndex = AS_StorageError_Base - 32;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidLanguageCode = AS_StorageError_Base - 33;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidMediaType = AS_StorageError_Base - 34;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidMetadata = AS_StorageError_Base - 35;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidMetadataName = AS_StorageError_Base - 36;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidOperation = AS_StorageError_Base - 37;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidParameter = AS_StorageError_Base - 38;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidProjectType = AS_StorageError_Base - 39;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidStringType = AS_StorageError_Base - 40;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidTime = AS_StorageError_Base - 41;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidTimeUnit = AS_StorageError_Base - 42;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidTrackType = AS_StorageError_Base - 43;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidHandle = AS_StorageError_Base - 44;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_InvalidSequence = AS_StorageError_Base - 45;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="Device and Media errors">Device and Media errors</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_DeviceError = AS_StorageError_Base - 60;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_DeviceNotReady = AS_StorageError_Base - 61;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_DeviceSelected = AS_StorageError_Base - 62;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_MediaFull = AS_StorageError_Base - 63;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_NotEnoughStorage = AS_StorageError_Base - 64;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_DeviceInUse = AS_StorageError_Base - 65;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_DeviceInQuickUse = AS_StorageError_Base - 66;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_TrackCountOverflow = AS_StorageError_Base - 70;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_DeviceSenseError = AS_StorageError_Base - 71;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="File Handling errors">File Handling errors</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_FileExists = AS_StorageError_Base - 80;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_FileNotFound = AS_StorageError_Base - 81;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_FolderExists = AS_StorageError_Base - 82;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_FolderNotFound = AS_StorageError_Base - 83;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="Metadata verification errors">Metadata verification errors</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_MetadataNotFound = AS_StorageError_Base - 100;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_MetadataTypeMismatch = AS_StorageError_Base - 101;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="Cancel error code">Cancel error code</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_UserCancelled = AS_StorageError_Base - 120;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>&#47;&#47; <B><A ID="Verify errors">Verify errors</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_DataMiscompare = AS_StorageError_Base - 140;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_WriteError = AS_StorageError_Base - 141;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>static const AS_StorageError AS_StorageError_ReadError = AS_StorageError_Base - 142;</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<HR SIZE=2 WIDTH="93%"><BR><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="OS and Compiler Definitions">5.3 &nbsp;OS and Compiler Definitions</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section includes the following defines related to the platform (OS) and compiler:</P>

<P CLASS="LinksList"><A HREF="#AS_Volume_Path_Delimiter">AS_Volume_Path_Delimiter</A>, <A HREF="#MSC_VER">MSC_VER</A>, <A HREF="#OS defines">OS defines</A></P>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>const SInt8 <B><A ID="AS_Volume_Path_Delimiter">AS_Volume_Path_Delimiter</A></B> = &#39;&#47;&#39;;</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>#ifdef _<B><A ID="MSC_VER">MSC_VER</A></B></TD>
<TD>&nbsp;</TD></TR>
<TR><TD>typedef signed __int8 SInt8;</TD>
<TD>&#47;&#47; signed 8-bit integer</TD></TR>
<TR><TD>typedef unsigned __int8 UInt8;</TD>
<TD>&#47;&#47; unsigned 8-bit integer</TD></TR>
<TR><TD>typedef signed __int16 SInt16;</TD>
<TD>&#47;&#47; signed 16-bit integer</TD></TR>
<TR><TD>typedef unsigned __int16 UInt16;</TD>
<TD>&#47;&#47; unsigned 16-bit integer</TD></TR>
<TR><TD>typedef signed __int32 SInt32;</TD>
<TD>&#47;&#47; signed 32-bit integer</TD></TR>
<TR><TD>typedef unsigned __int32 UInt32;</TD>
<TD>&#47;&#47; unsigned 32-bit integer</TD></TR>
<TR><TD>typedef signed __int64 SInt64;</TD>
<TD>&#47;&#47; signed 64-bit integer</TD></TR>
<TR><TD>typedef unsigned __int64 UInt64;</TD>
<TD>&#47;&#47; unsigned 64-bit integer</TD></TR>
<TR><TD>#else</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>typedef signed char SInt8;</TD>
<TD>&#47;&#47; signed 8-bit integer</TD></TR>
<TR><TD>typedef unsigned char UInt8;</TD>
<TD>&#47;&#47; unsigned 8-bit integer</TD></TR>
<TR><TD>typedef signed short SInt16;</TD>
<TD>&#47;&#47; signed 16-bit integer</TD></TR>
<TR><TD>typedef unsigned short UInt16;</TD>
<TD>&#47;&#47; unsigned 16-bit integer</TD></TR>
<TR><TD>typedef signed long SInt32;</TD>
<TD>&#47;&#47; signed 32-bit integer</TD></TR>
<TR><TD>typedef unsigned long UInt32;</TD>
<TD>&#47;&#47; unsigned 32-bit integer</TD></TR>
<TR><TD>typedef signed long long SInt64;</TD>
<TD>&#47;&#47; signed 64-bit integer</TD></TR>
<TR><TD>typedef unsigned long long UInt64;</TD>
<TD>&#47;&#47; unsigned 64-bit integer</TD></TR>
<TR><TD>#endif</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<BR><TABLE ALIGN="center" WIDTH="93%" BORDER="1" RULES="rows" CELLSPACING="0" CELLPADDING="5" CLASS="TableCode"><TBODY VALIGN="top">
<COLGROUP><COL WIDTH="6*"><COL WIDTH="4*"></COLGROUP>
<TR CLASS="TableSansHead"><TD>Syntax</TD>
<TD>Description</TD></TR>
<TR><TD>#if defined(__<B><B><A ID="APPLE">APPLE</A></B></B>__)</TD>
<TD>&#47;&#47; <B><B><A ID="OS defines">OS defines</A></B></B></TD></TR>
<TR><TD>#define AS_APPLE</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_CALLBACK</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#ifndef AS_API</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#ifdef __GNUC__</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_API __attribute__((visibility(&quot;default&quot;)))</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#endif</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#endif</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#elif defined(__<B><A ID="unix">unix</A></B>__)</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_UNIX</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_CALLBACK</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#ifndef AS_API</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_API</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#endif</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#elif defined(_<B><A ID="WIN32">WIN32</A></B>)</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#include &lt;wchar.h&gt;</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_WIN32</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_CALLBACK __stdcall</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#ifndef AS_API</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#define AS_API __stdcall</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#endif</TD>
<TD>&nbsp;</TD></TR>
<TR><TD>#endif</TD>
<TD>&nbsp;</TD></TR></TBODY></TABLE>

<P CLASS="IndentSans"><A HRef= "#chapter">Top</A></P>
</BODY>
</HTML>

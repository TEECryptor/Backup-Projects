<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>AuthorScript&#174; Advanced Data 3.2 SDK Guide - Chapter 3</TITLE>
<!-- AuthorScript Advanced Data SDK version 3.2 -->
<!-- HTML version generated by DelPhi on 060707 -->
<!-- (c) 2002-2007 Sonic Solutions. All Rights Reserved. -->
<LINK REL=STYLESHEET TYPE="text/css" HREF="AD_Styles-MAIN.css">
</HEAD>

<BODY>
<TABLE WIDTH="100%" ALIGN=center BORDER=0><TBODY>
<TR><TD WIDTH=520><A ID="chapter"><IMG SRC="AD_Images/AD_Banner.jpg" WIDTH=520 HEIGHT=71></A>
<TR><TD WIDTH=520 HEIGHT=52 ALIGN=right VALIGN=top><P CLASS="IndentSans" ALIGN="Right">&#169; 2002-2007 Sonic Solutions<SUP>&#153;</SUP>. All Rights Reserved.</P></TD><TD></TD></TR></TBODY></TABLE>
<P CLASS="Heading1"><A ID="Working With AuthorScript AD">3 &nbsp;Working With AuthorScript AD</A></P>
<P CLASS="IndentSerif">AuthorScript Advanced Data supports the creation and manipulation of volumes and their file system objects (directories and files). This chapter covers some of the factors such as volume access mode and call sequence that can affect the successful outcome of AuthorScript AD functions, and then provides commented sample code illustrating some common file system-related tasks:</P>
<UL CLASS="IndentSerif_List"><LI><A HREF="#Device Types">Device Types</A></LI>
<LI><A HREF="#Access Mode, File System, and Media">Access Mode, File System, and Media</A></LI>
<LI><A HREF="#Call Sequence">Call Sequence</A></LI>
<LI><A HREF="#Property Get and Set Methods">Property Get and Set Methods</A></LI>
<LI><A HREF="#Canceling Operations">Canceling Operations</A></LI>
<LI><A HREF="#Device Selection and State">Device Selection and State</A></LI>
<LI><A HREF="#Media Format and State">Media Format and State</A></LI>
<LI><A HREF="#Format for Joliet">Format for Joliet</A></LI>
<LI><A HREF="#Write Data to Files">Write Data to Files</A></LI>
<LI><A HREF="#Stream from Disc">Stream from Disc</A></LI></UL>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Device Types">3.1 &nbsp;Device Types</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">For the purpose of AuthorScript AD, a device is considered to be one of the following types of drives:</P>
<UL CLASS="IndentSerif_List"><LI>CD-R&#47;-RW</LI>
<LI>DVD-R&#47;+R, including dual-layer (DL)</LI>
<LI>DVD-RW&#47;+RW</LI>
<LI>DVD-RAM</LI>
<LI>BD-RE</LI></UL>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Access Mode, File System, and Media">3.2 &nbsp;Access Mode, File System, and Media</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">The operations that AuthorScript AD functions may perform at a given moment depend in part on the volume&#39;s access mode, file system type, and media kind. In particular, the access mode (see <A HREF="AD_Guide_5.htm#Access flag">Access flag</A>) determines whether or not a volume may be written to and how writing is performed. The access mode is specified when the volume is mounted (see <A HREF="AD_Guide_7.htm#AS_Volume_Mount">AS_Volume_Mount</A>) or formatted (see <A HREF="AD_Guide_7.htm#AS_Volume_Create">AS_Volume_Create</A>). A volume may be in one of the following three access modes:</P>
<UL CLASS="IndentSerif_List"><LI><B><A ID="ReadOnly mode">ReadOnly mode</A></B>:<BR>
- used when mounting an existing volume with AS_Volume_Mount;<BR>
- used only to read data; does not allow writing to the volume.</LI>
<LI><B><A ID="Mastering mode">Mastering mode</A></B>: <BR>
- used when mounting an existing volume with AS_Volume_Mount or formatting a new volume with AS_Volume_Create;<BR>
- allows creation of an empty file system object (file or directory) on the volume with <A HREF="AD_Guide_7.htm#AS_Volume_CreateEntry">AS_Volume_CreateEntry</A>;<BR>
- used to write complete files and directories of known size from a data source to the volume with <A HREF="AD_Guide_7.htm#AS_Volume_CreateEntryFromHD">AS_Volume_CreateEntryFromHD</A> or <A HREF="AD_Guide_7.htm#AS_Volume_CreateFileFromStream">AS_Volume_CreateFileFromStream</A>;<BR>
- allows deletion of existing files or directories with <A HREF="AD_Guide_7.htm#AS_Volume_DeleteEntry">AS_Volume_DeleteEntry</A>;<BR>
- does not allow writing data into an existing file;<BR>
- neither file data nor file system information is actually recorded to the volume until <A HREF="AD_Guide_7.htm#AS_Volume_Flush">AS_Volume_Flush</A> is called, at which time the source data is read (either from source file, or via a callback function) and written to the disc along with the entire file system.</LI>
<LI><B><A ID="RTTD mode">RTTD mode</A></B>:<BR>
- used when mounting an existing volume with AS_Volume_Mount or formatting a new volume with AS_Volume_Create;<BR>
- allows all file and directory operations listed above under Mastering mode (though Mastering mode is preferred when the amount of data to be written is known in advance of recording);<BR>
- used to open a file on the volume (see <A HREF="AD_Guide_7.htm#AS_Volume_OpenFile">AS_Volume_OpenFile</A>) and append to that file data of unknown size with <A HREF="AD_Guide_7.htm#AS_File_Write">AS_File_Write</A>;<BR>
- file data is recorded to the volume in real time as AS_File_Write is called. File system information is not actually recorded to the volume until AS_Volume_Flush is called.</LI></UL>
<P CLASS="IndentSerif"><B>NOTES</B>:<BR>
<B>&#187;</B> The entire file system is written to disc each time AS_Volume_Flush is called. If the volume&#39;s media is CD or write-once DVD, each Flush operation creates a new session on the disc (CD-RW media is not overwritten).<BR>
<B>&#187;</B> All writing to CD-R or CD-RW media is TAO (one track per session in <SPAN CLASS="Courier_New_Inline">Mastering </SPAN>access mode; multiple tracks per session in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>access mode).</P>

<P CLASS="SubHead_Sans12"><A ID="Access mode support">Access mode support</A></P>
<P CLASS="IndentSerif">The following table shows which access modes are supported for each combination of file system and media kind:</P>
<TABLE ALIGN="center" WIDTH="93%" BORDER="1" CELLSPACING="0" CELLPADDING="5" CLASS="TableSans"><TBODY VALIGN="top">
<TR CLASS="TableSansHead"><TD>File System</TD>
<TD>CD<BR>
(all formats)</TD>
<TD>DVD-R&#47;+R</TD>
<TD>DVD-RW&#47;+RW,<BR>
DVD-RAM, BD-RE</TD></TR>
<TR><TD><B>ISO</B> (any)</TD>
<TD>ReadOnly,<BR>
Mastering</TD>
<TD>ReadOnly,<BR>
Mastering</TD>
<TD>ReadOnly,<BR>
Mastering,<BR>
RTTD</TD></TR>
<TR><TD><B>Joliet</B></TD>
<TD>ReadOnly,<BR>
Mastering</TD>
<TD>ReadOnly,<BR>
Mastering</TD>
<TD>ReadOnly,<BR>
Mastering,<BR>
RTTD</TD></TR>
<TR><TD><B>UDF 1.02</B></TD>
<TD>ReadOnly,<BR>
Mastering</TD>
<TD>ReadOnly,<BR>
Mastering</TD>
<TD>ReadOnly,<BR>
Mastering,<BR>
RTTD</TD></TR>
<TR><TD><B>UDF 1.50 - 2.6</B></TD>
<TD>ReadOnly,<BR>
Mastering,<BR>
RTTD</TD>
<TD>ReadOnly,<BR>
Mastering,<BR>
RTTD</TD>
<TD>ReadOnly,<BR>
Mastering,<BR>
RTTD</TD></TR>
<TR><TD><B>CD-Audio, VCD, SVCD</B></TD>
<TD>Not supported</TD>
<TD>N.A.</TD>
<TD>N.A.</TD></TR></TBODY></TABLE>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Call Sequence">3.3 &nbsp;Call Sequence</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">Mastery of AuthorScript AD functions depends in part on understanding the order in which functions must be called to obtain a successful result. The following list provides links to descriptions of basic call sequences for various AuthorScript AD tasks:</P>
<UL CLASS="IndentSerif_List"><LI>For a look at the steps typically involved in setting up to use a device, see <A HREF="AD_Guide_6.htm#Device call sequence"><SPAN CLASS="Arial_Inline"><B>Device call sequence</B></SPAN></A>;</LI>
<LI>For a look at the steps typically involved in setting up to access and modify a volume, see <A HREF="AD_Guide_7.htm#Volume call sequence"><SPAN CLASS="Arial_Inline"><B>Volume call sequence</B></SPAN></A>;</LI>
<LI>For a look at the steps typically involved in setting up to read from or write to a file, see <A HREF="AD_Guide_7.htm#Read&#47;Write call sequence"><SPAN CLASS="Arial_Inline"><B>Read&#47;Write call sequence</B></SPAN></A>.</LI></UL>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Property Get and Set Methods">3.4 &nbsp;Property Get and Set Methods</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AuthorScript AD supports two alternative methods to get&#47;set the properties of a file system object. The distinction is based on how the object is identified:</P>
<UL CLASS="IndentSerif_List"><LI><B><A ID="Full path (property get&#47;set):">Full path (property get&#47;set):</A></B><BR>
- the file system object is identified by its full path within the currently mounted volume;<BR>
- applies to files and directories;<BR>
- includes the calls <A HREF="AD_Guide_7.htm#AS_Volume_GetEntryProperty">AS_Volume_GetEntryProperty</A> and <A HREF="AD_Guide_7.htm#AS_Volume_SetEntryProperty">AS_Volume_SetEntryProperty</A>;<BR>
- the calls are available for all media kinds supported by AS Imaging.</LI>
<LI><B><A ID="File reference (property get&#47;set):">File reference (property get&#47;set):</A></B><BR>
- the object is identified by a file reference (<A HREF="AD_Guide_5.htm#AS_File">AS_File</A> struct);<BR>
- applies to files only;<BR>
- the file must be open (see <A HREF="AD_Guide_7.htm#AS_Volume_OpenFile">AS_Volume_OpenFile</A>);<BR>
- includes the calls <A HREF="AD_Guide_7.htm#AS_File_GetProperty">AS_File_GetProperty</A> and <A HREF="AD_Guide_7.htm#AS_File_SetProperty">AS_File_SetProperty</A>;<BR>
- the calls are available for all media kinds supported by AS Imaging except CD-R&#47;RW.</LI></UL>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Canceling Operations">3.5 &nbsp;Canceling Operations</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AuthorScript AD functions that take a callback as a parameter also provide the host application with the ability to cancel an operation in progress. These functions include <A HREF="AD_Guide_7.htm#AS_Volume_Create">AS_Volume_Create</A>, <A HREF="AD_Guide_7.htm#AS_Volume_Mount">AS_Volume_Mount</A>, and <A HREF="AD_Guide_7.htm#AS_Volume_Flush">AS_Volume_Flush</A>.<BR>
<BR>
<B>NOTES</B>:<BR>
<B><FONT COLOR="ff0000">!</FONT> </B>After canceling an operation that writes to the media (e.g. AS_Volume_Mount in Mastering or RTTD mode, or AS_Volume_Flush), the disc is usually left in an unstable&#47;unusable state.<BR>
<B><FONT COLOR="ff0000">!</FONT> </B>After canceling AS_Volume_Mount in <SPAN CLASS="Courier_New_Inline">ReadOnly </SPAN>mode, the volume state should not be relied upon and the existing volume reference should not be used for further operations. If additional operations are required, the volume should be closed, re-opened, and then mounted or formatted. <BR>
<B>&#187;</B> Cancel is not available on AS_StorageDevice_EraseMedia or AS_StorageDevice_OpenVolume.<BR>
<B>&#187;</B> If a volume on write-once media is open in <SPAN CLASS="Courier_New_Inline">RTTD </SPAN>mode, canceling AS_Volume_Create will stop writing of the file system. For all other access modes and media types, canceling AS_Volume_Create has no effect on the media.<BR>
<B>&#187;</B> If AS_Volume_Flush is cancelled while files created by AS_Volume_CreateFileFromStream are queued to be flushed, the callback will stop asking for data to write.</P>

<P CLASS="SubHead_Sans12"><A ID="Sample code for canceling operations">Sample code for canceling operations</A></P>
<P CLASS="IndentSerif">The following snippet shows canceling via callback function:</P>
<P CLASS="Code"><BR>
AS_StorageError AS_CALLBACK ProgressCallback(UInt32 percentcomplete, void *context)<BR>
{<BR>
&nbsp;&nbsp;std::cout &lt;&lt; &quot;Progress:&quot; &lt;&lt; percentcomplete &lt;&lt; &quot;% complete&quot; &lt;&lt; std::endl &lt;&lt; std::flush;<BR>
&nbsp;&nbsp;context;<BR>
&nbsp;&nbsp;&#47;&#47; cancel function in progress<BR>
&nbsp;&nbsp;if (UserClickedCancel())<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return AS_StorageError_UserCancelled;<BR>
&nbsp;&nbsp;return AS_StorageError_None;<BR>
}</P>
<P CLASS="IndentSerif">When writing in RTTD mode, the host application can cancel a write operation by breaking from the write loop:</P>
<P CLASS="Code"><BR>
while (WeHaveDataComingIn())<BR>
{<BR>
&nbsp;&nbsp;&#47;&#47; For bytes actually written:<BR>
&nbsp;&nbsp;AS_File::Cnt tWrote, avWrote;<BR>
&nbsp;&nbsp;&#47;&#47; Number of 1st file data bytes to write:<BR>
&nbsp;&nbsp;AS_File::Cnt tSize = tChunk;<BR>
&nbsp;&nbsp;&#47;&#47; Write chunk sizes to keep the disc streaming for RTTD._&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_File_Write">AS_File_Write</A> (oneFile, tSize, tBuf, &tWrote);<BR>
<BR>
&nbsp;&nbsp;if (UserClickedCancel())<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;_<BR>
}</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Device Selection and State">3.6 &nbsp;Device Selection and State</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AuthorScript AD&#39;s device-related calls use a device reference (<A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct) to identify the drive to which they refer. <A HREF="AD_Guide_6.htm#AS_OpenStorageDevice">AS_OpenStorageDevice</A> specifies which device is referenced, using a drive index, provided by the OS, that identifies the system&#39;s internal drive. The following example code shows that process, followed by querying the state of the specified drive.</P>
<P CLASS="Code"><BR>
&#47;&#47; Suggest keeping global polling flag, and making<BR>
&#47;&#47; drive state global to stop polling if drive busy.<BR>
<BR>
bool gMediaInUse = false;<BR>
<BR>
AS_StorageDevice &nbsp;&nbsp;internalDrive;<BR>
<BR>
<A HREF="AD_Guide_6.htm#AS_OpenStorageDevice">AS_OpenStorageDevice</A>(1, internalDrive);<BR>
<BR>
&#47;&#47; Some Polling thread<BR>
while (!gMediaInUse)<BR>
{<BR>
&nbsp;&nbsp;AS_StorageDevice::State state;<BR>
<BR>
&nbsp;&nbsp;if ((<A HREF="AD_Guide_6.htm#AS_StorageDevice_GetState">AS_StorageDevice_GetState</A>(internalDrive, state)) == AS_StorageError_None)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;switch (state)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Media is spun up and available.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case AS_StorageDevice::State_Ready:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Do something with media:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HandleNewMedia(); &#47;&#47; see <A HREF="#Media Format and State"><B>Media Format and State</B></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; No media in drive.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case AS_StorageDevice::State_Not_Ready:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(240);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Media spinning up. Alert user? <BR>
&nbsp;&nbsp;&nbsp;&nbsp;case AS_StorageDevice::State_Becoming_Ready:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
};<BR>
<BR>
<A HREF="AD_Guide_6.htm#AS_StorageDevice_Close">AS_StorageDevice_Close</A>(internalDrive);</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Media Format and State">3.7 &nbsp;Media Format and State</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">After determining the device state, code such as the following example would typically be used to detect the format and state of media in the device:</P>
<P CLASS="Code"><BR>
&#47;&#47; HandleNewMedia() sample code:<BR>
<BR>
gMediaInUse = true; &#47;&#47; Stop the polling<BR>
<BR>
&#47;&#47; Check if media is blank<BR>
AS_StorageDevice::MediaKind kind;<BR>
AS_StorageDevice::MediaState state;<BR>
<BR>
if ((<A HREF="AD_Guide_6.htm#AS_StorageDevice_GetMediaProperty">AS_StorageDevice_GetMediaProperty</A>(internalDrive, AS_StorageDevice::MedProp_Kind, sizeof(kind), &kind, NULL) == AS_StorageError_None)<BR>
&nbsp;&nbsp;&& (AS_StorageDevice_GetMediaProperty(internalDrive, AS_StorageDevice::MedProp_State, sizeof(state), &state, NULL) == AS_StorageError_None )<BR>
{<BR>
&nbsp;&nbsp;&#47;&#47; Offer many choices here based on media kind&#47;state.<BR>
&nbsp;&nbsp;&#47;&#47; Example shown: format blank DVD-R&#47;RW as Joliet.<BR>
&nbsp;&nbsp;switch (kind)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;case AS_StorageDevice::MediaIsDvdr:<BR>
&nbsp;&nbsp;case AS_StorageDevice::MediaIsDvdrw:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Media is blank.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (state & AS_StorageDevice::MediaIsBlank)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Insert dialog here: <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; assume user chooses to format as Joliet.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormatJoliet(); &#47;&#47; See <A HREF="#Format for Joliet"><B>Format for Joliet</B></A>.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Media not blank.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Mount media, check contents<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AS_Volume vol;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AS_Volume::FS_Type format;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((<A HREF="AD_Guide_7.htm#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>(internalDrive, format, callback, userdata, vol) == AS_StorageError_None)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_Mount">AS_Volume_Mount</A>(vol, AS_Volume::ReadOnly, callback, progressUserdata);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReadFromDisc(vol);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_Close">AS_Volume_Close</A>(vol);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;}<BR>
}<BR>
<BR>
gMediaInUse = false; &#47;&#47; Start the polling thread?</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Format for Joliet">3.8 &nbsp;Format for Joliet</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This sample code covers formatting the volume in Joliet. </P>
<P CLASS="Code"><BR>
&#47;&#47; FormatForJoliet() sample code:<BR>
<BR>
void FormatForJoliet(const AS_StorageDevice & internalDrive)<BR>
{<BR>
&nbsp;&nbsp;AS_Volume vol;<BR>
&nbsp;&nbsp;AS_StorageError err;<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Create an internal object for the volume<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_StorageDevice_OpenVolume">AS_StorageDevice_OpenVolume</A>(internalDrive, NULL, callback, userdata, vol);<BR>
<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_Create">AS_Volume_Create</A>(vol, AS_Volume::FS_Joliet, AS_File_Path(&quot;VolumeName&quot;), AS_Volume::Mastering, callback, progressUserdata);<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Write the data <BR>
&nbsp;&nbsp;WriteData(vol); &#47;&#47; See <A HREF="#Write Data to Files"><B>Write Data to Files</B></A>.<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Write updated UDF structures to the disc<BR>
&nbsp;&nbsp;&#47;&#47; Flush is required to add new files to the file system<BR>
&nbsp;&nbsp;&#47;&#47; (without it, disc could be left corrupt and unreadable).<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_Flush">AS_Volume_Flush</A>(vol, callback, userdata, AS_Volume::Border_Close);<BR>
<BR>
&#47;&#47; Dump the internal object<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_Close">AS_Volume_Close</A>(vol);<BR>
}</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Write Data to Files">3.9 &nbsp;Write Data to Files</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section uses two files to illustrate two different methods of adding data to disc. The first part of the code shows streaming data to a file on a volume that is open in RTTD access mode. The second part shows queuing a file for subsequent writing to disc as part of a flush operation (see <A HREF="AD_Guide_7.htm#AS_Volume_Flush">AS_Volume_Flush</A>).</P>
<P CLASS="Code"><BR>
void WriteData(const AS_Volume & vol)
<BR>
{<BR>
&nbsp;&nbsp;AS_StorageError err = AS_StorageError_None;<BR>
&nbsp;&nbsp;AS_File oneFile;<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Define data chunk as 32k to make ECC blocks.<BR>
&nbsp;&nbsp;UInt32 tChunk = 16 * 2048; <BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Create directory to store files in<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_CreateEntry">AS_Volume_CreateEntry</A> (vol, &quot;&#47;tmp&quot;, AS_File::File_IsDir, true);<BR>
&nbsp;&nbsp;if (err != AS_StorageError_None)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return err;<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; First data file:<BR>
&nbsp;&nbsp;&#47;&#47; open destination file on optical media for RTTD<BR>
&nbsp;&nbsp;&#47;&#47; (a file may be opened for write without first being created).<BR>
<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_OpenFile">AS_Volume_OpenFile</A> (vol, &quot;&#47;tmp&#47;file1.data&quot;, AS_File::Append, oneFile);<BR>
&nbsp;&nbsp;if (err != AS_StorageError_None)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return err;<BR>
<BR>
&nbsp;&nbsp;while (WeHaveDataComingIn())<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; For bytes actually written:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;AS_File::Cnt tWrote, avWrote; <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Number of 1st file data bytes to write:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;AS_File::Cnt tSize = tChunk;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Write chunk sizes to keep the disc streaming for RTTD.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_File_Write">AS_File_Write</A> (oneFile, tSize, tBuf, &tWrote);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (err != AS_StorageError_None)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (UserClickedCancel())<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &#47;&#47; exit the write loop to cancel writing to file<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Dispose of internal objects<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_File_Close">AS_File_Close</A> (oneFile);<BR>
&nbsp;&nbsp;if (err != AS_StorageError_None)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return err;<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Second data file:<BR>
&nbsp;&nbsp;&#47;&#47; queue to write later when flushing volume.<BR>
&nbsp;&nbsp;AS_StringA srcEntry = &quot;c:\\test.txt&quot;;<BR>
&nbsp;&nbsp;AS_StringA dstEntry = &quot;&#47;tmp&#47;file2.data&quot;;<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_CreateEntryFromHD">AS_Volume_CreateEntryFromHD</A> (vol, dstEntry, srcEntry);<BR>
&nbsp;&nbsp;if (err != AS_StorageError_None)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return err;<BR>
}</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Stream from Disc">3.10 &nbsp;Stream from Disc</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section illustrates streaming data from two files on an open volume to two buffers.</P>
<P CLASS="Code"><BR>
void StreamDataFromDisc(AS_Volume vol)<BR>
{<BR>
&nbsp;&nbsp;AS_File oneFile;<BR>
&nbsp;&nbsp;AS_File twoFile;<BR>
&nbsp;&nbsp;AS_StorageError err;<BR>
&nbsp;&nbsp;AS_File_Size avSize;<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Open files on optical disc<BR>
&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_Volume_OpenFile">AS_Volume_OpenFile</A>(vol, &quot;&#47;tmp&#47;file1.data&quot;, AS_File::Read, oneFile);<BR>
&nbsp;&nbsp;err = AS_Volume_OpenFile(vol, &quot;&#47;tmp&#47;file2.data&quot; AS_File::Read, twoFile); <BR>
<BR>
<A HREF="AD_Guide_7.htm#&nbsp;&nbsp;AS_Volume_GetFileInfo">&nbsp;&nbsp;AS_Volume_GetFileInfo</A>(vol, &quot;&#47;tmp&#47;file1.data&quot;, NULL, avSize);<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Setup buffers of tChunk, avChunk named tBuf, avBuf<BR>
&nbsp;&nbsp;&#47;&#47; Monitor stream; stop when there&#39;s no more data.<BR>
&nbsp;&nbsp;while (avSize &gt; 0)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Read chunk-size data from file to buffer.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;err = <A HREF="AD_Guide_7.htm#AS_File_Read">AS_File_Read</A>(oneFile, tChunk, tBuf, NULL);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Do something with the data in the buffer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Process1stData(tBuf);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Read chunk-size AV data from file to buffer.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;err = AS_File_Read(twoFile, avChunk, avBuf, NULL);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Do something with the AV data in the buffer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Process2ndData(avBuf);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&#47;&#47; Dispose of internal objects<BR>
&nbsp;&nbsp;<A HREF="AD_Guide_7.htm#AS_File_Close">AS_File_Close</A>(oneFile);<BR>
&nbsp;&nbsp;AS_File_Close(twoFile);<BR>
}</P>

<P CLASS="IndentSans"><A HRef= "#chapter">Top</A></P>
</BODY>
</HTML>

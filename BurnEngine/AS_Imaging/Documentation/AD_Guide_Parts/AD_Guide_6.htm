<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>AuthorScript&#174; Advanced Data 3.2 SDK Guide - Chapter 6</TITLE>
<!-- AuthorScript Advanced Data SDK version 3.2 -->
<!-- HTML version generated by DelPhi on 060707 -->
<!-- (c) 2002-2007 Sonic Solutions. All Rights Reserved. -->
<LINK REL=STYLESHEET TYPE="text/css" HREF="AD_Styles-MAIN.css">
</HEAD>

<BODY>
<TABLE WIDTH="100%" ALIGN=center BORDER=0><TBODY>
<TR><TD WIDTH=520><A ID="chapter"><IMG SRC="AD_Images/AD_Banner.jpg" WIDTH=520 HEIGHT=71></A>
<TR><TD WIDTH=520 HEIGHT=52 ALIGN=right VALIGN=top><P CLASS="IndentSans" ALIGN="Right">&#169; 2002-2007 Sonic Solutions<SUP>&#153;</SUP>. All Rights Reserved.</P></TD><TD></TD></TR></TBODY></TABLE>
<P CLASS="Heading1"><A ID="Devices and Media">6 &nbsp;Devices and Media</A></P>
<P CLASS="IndentSerif">This chapter describes AuthorScript Advanced Data functions related to devices and media. These functions are covered in the following sections:</P>
<UL CLASS="IndentSerif_List"><LI><A HREF="#Device Management">Device Management</A></LI>
<LI><A HREF="#Device and Media Profile">Device and Media Profile</A></LI>
<LI><A HREF="#Device Commands">Device Commands</A></LI></UL>
<P CLASS="IndentSerif">To find a specific call by name, see <A HREF="AD_Guide_4.htm">Chapter 4</A>, <SPAN CLASS="Arial_Inline"><B>Function Index</B></SPAN>.<BR>
<BR>
Each function entry below includes a description of the usage of the function, a list of values typically returned when the function is called, and the function&#39;s parameter(s). Each parameter is designated as one of the following:<BR>
-  <SPAN CLASS="Courier_New_Inline"><I>[IN]</I> </SPAN>the value is passed into the function from the object; the object is not modified by the call.<BR>
- <SPAN CLASS="Courier_New_Inline"><I>[IN&#47;OUT]</I> </SPAN>the value is passed into the function from the object; the object may subsequently be modified by the call.<BR>
- <SPAN CLASS="Courier_New_Inline"><I>[OUT]</I> </SPAN>the value of the object is filled in by the function.<BR>
<BR>
<B><FONT COLOR="ff0000">!</FONT> NOTE</B>: This document discusses the functionality of all calls that are part of the overall AuthorScript AD SDK version for which this documentation has been provided. The availability of a particular call to a given AuthorScript AD licensee, however, depends on the specifics of the license. Please contact Sonic if you have any questions about which calls are covered in your AuthorScript AD license.</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Device Management">6.1 &nbsp;Device Management</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section covers the following calls:</P>

<P CLASS="LinksList"><A HREF="#AS_GetStorageDeviceCount">AS_GetStorageDeviceCount</A>, <A HREF="#AS_OpenStorageDevice">AS_OpenStorageDevice</A>, <A HREF="#AS_StorageDevice_Close">AS_StorageDevice_Close</A>, <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A></P>
<P CLASS="IndentSerif">These calls are used to make a device available to AuthorScript AD and to release that device when it is no longer needed, as well as to control device access and set up device callbacks. For a list of device types supported by AuthorScript AD, see <A HREF="AD_Guide_3.htm#Device Types"><SPAN CLASS="Arial_Inline"><B>Device Types</B></SPAN></A>.</P>

<P CLASS="SubHead_Sans12"><A ID="Device call sequence">Device call sequence</A></P>
<P CLASS="IndentSerif">The steps involved in setting up to use a device would typically be as follows:</P>
<OL CLASS="IndentSerif_NumList"><LI>Call <A HREF="#AS_GetStorageDeviceCount">AS_GetStorageDeviceCount</A> (with the <I>flag</I> parameter set to the scan flags constant <SPAN CLASS="Courier_New_Inline">Scan_All = 0</SPAN>) to count the number of devices currently on the system.</LI>
<LI>Call <A HREF="#AS_OpenStorageDevice">AS_OpenStorageDevice</A>, specifying the device to open by its OS-provided drive index (which must be less than the value of <I>count</I> as returned from AS_GetStorageDeviceCount in step 1). An <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct is generated for the device.</LI>
<LI>Once the device is opened, it is specified in subsequent calls by passing a reference to the AS_StorageDevice struct. The device reference is also used to obtain a volume reference, which allows manipulation of file system objects (see <A HREF="AD_Guide_7.htm">Chapter 7</A>).</LI>
<LI>Reserve the device with <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>, then get the state of the device with <A HREF="#AS_StorageDevice_GetState">AS_StorageDevice_GetState</A>, which will enable subsequent querying of media properties.</LI>
<LI>Once the device is in ready state, the rest of the functions in this chapter may be used to retrieve information about drive properties and about the state and properties of the media in the drive, as well as to send commands to the device.</LI>
<LI>When work with the device is completed, <A HREF="#AS_StorageDevice_Close">AS_StorageDevice_Close</A> may be called to close the session for the device containing the volume.</LI></OL>
<P CLASS="IndentSerif"><B>NOTE</B>: Once a device is open, it should be reserved with <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A> prior to calling the volume functions (AS_Volume_<I>Xxx</I>) and file functions (AS_File_<I>Xxx</I>) covered in <A HREF="AD_Guide_7.htm">Chapter 7</A>, as well as many of the device functions covered below.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_GetStorageDeviceCount">AS_GetStorageDeviceCount</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_GetStorageDeviceCount outputs a count of the devices on the system. Depending on the value specified with the parameter <I>flags</I>, the count will cover all devices, optical devices only, or tape devices only. The number of devices is output with <I>count</I>.<BR>
<BR>
<B>NOTE</B>: This call is not needed in environments (e.g. embedded platforms) where it is certain that only a single device is present.</P>

<P CLASS="SubHead_Sans11">Syntax</P>
<P CLASS="Code">
AS_StorageError AS_API AS_GetStorageDeviceCount(<BR>
&nbsp;&nbsp;AS_StorageDevice::Scan_Flags flag,<BR>
&nbsp;&nbsp;UInt32 & count<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">flag [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Scan flags">Scan flags</A> constant (AS_StorageDevice::Scan_Flags) specifying the type of count to perform.</P>

<P CLASS="Code_Ital">count [OUT]</P>
<P CLASS="Def_Field">A UInt32 that is to be filled in with the number of devices on the system.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the flags are not defined.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceSelected</SPAN>: devices are currently in use by the API.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unknown software error.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_OpenStorageDevice">AS_OpenStorageDevice</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_OpenStorageDevice fills in an <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct for a given device and retrieves a device reference. The reference, output with <I>device</I>, is used to specify the device in subsequent device-related calls. The device for which to retrieve the reference is specified with the parameter <I>index</I>, which is used to pass the OS-provided index of the drive. <BR>
<BR>
<B>NOTE</B>:<BR>
<B>&#187;</B> The value of <I>index</I> must be less than the count output by <A HREF="#AS_GetStorageDeviceCount ">AS_GetStorageDeviceCount </A>when counting all devices on the system (<I>flag</I> parameter set to <SPAN CLASS="Courier_New_Inline">Scan_All = 0</SPAN>).<BR>
<B>&#187;</B> This function must be called before any functions requiring a device reference (<SPAN CLASS="Courier_New_Inline">AS_StorageDevice</SPAN>).<BR>
<B>&#187;</B> The optional parameter <I>path</I> should be specified as 0 unless the device reference is being obtained for a file, in which case <I>index</I> will be ignored and the reference will actually represent the file at the given path.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_OpenStorageDevice(<BR>
&nbsp;&nbsp;UInt32 index,<BR>
&nbsp;&nbsp;AS_StorageDevice & device,<BR>
&nbsp;&nbsp;const AS_String & path = AS_String()<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">index [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the index (from OS) for the drive to open.</P>

<P CLASS="Code_Ital">device [OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct that is to be filled in for the selected device.</P>

<P CLASS="Code_Ital">path [IN]</P>
<P CLASS="Def_Field">Optional: A constant reference to an <A HREF="AD_Guide_5.htm#AS_String">AS_String</A> struct specifying the path to a file that is to be represented as a device.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidIndex</SPAN>:  the value of <I>index</I> is greater than the count provided by AS_GetStorageDeviceCount.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_Fatal</SPAN>: unable to create a list of valid drives.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_Close">AS_StorageDevice_Close</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_Close closes the specified device and releases all associated memory.<BR>
<BR>
<B>NOTE</B>: This function must be called after all other device-related calls.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_Close(AS_StorageDevice & device);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN&#47;OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device to close.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: device reference is invalid.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device Management">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_ExclusiveAccess handles several tasks related to the exclusive access status of the specified device. Exclusive access facilitates orderly utilization of devices in multi-application environments, preventing unpredicatble results that can arise when two or more applications attempt to access a given device simultaneously.<BR>
<BR>
Depending on the value of the parameter <I>access_type</I> (enum AS_StorageDevice::ExclusiveAccess_Type), this function will perform one of the following operations:</P>
<UL CLASS="IndentSerif_List"><LI><B><A ID="Obtain">Obtain</A></B> (<SPAN CLASS="Courier_New_Inline">ExclusiveAccess_Obtain = 1</SPAN>) &#151; reserves the device for exclusive access by the host application. The parameter<I> access_name</I> is used to pass the name of the host application so that it may be identified to other applications attempting to access the device while it is reserved.</LI>
<LI><B><A ID="Quick Obtain">Quick Obtain</A></B> (<SPAN CLASS="Courier_New_Inline">ExclusiveAccess_Quick_Obtain = 2</SPAN>) &#151; same as Obtain, but signals the host application&#39;s intent to limit exclusive access to the device to 60 seconds or less, after which the host application intends to call this function again to release the device. This arrangement allows the application reserving the device to indicate to other applications that they should check back again soon to see if it is available.</LI>
<LI><B><A ID="Release">Release</A></B> (<SPAN CLASS="Courier_New_Inline">ExclusiveAccess_Release = 3</SPAN>) &#151; releases the host application&#39;s exclusive access to the device. The parameter<I> access_name</I> need not be specified.</LI>
<LI><B><A ID="Query">Query</A></B> (<SPAN CLASS="Courier_New_Inline">ExclusiveAccess_Query = 4</SPAN>) &#151; queries whether or not the specified device is currently reserved by an application. The parameter<I> access_name</I> need not be specified.</LI></UL>
<P CLASS="IndentSerif">If exclusive access to the specified device is not already reserved by an application when the function is called, the call&#39;s return value will be <SPAN CLASS="Courier_New_Inline">AS_StorageError_None </SPAN>and AuthorScript will not fill in the AS_String object referenced with <I>app_in_use_name</I>.<BR>
<BR>
If exclusive access to the device is already reserved, the values returned from the function vary depending on access type:</P>
<UL CLASS="IndentSerif_List"><LI>If access type = Obtain, Quick Obtain, or Query:<BR>
- the call&#39;s return value will be <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceInUse </SPAN>or <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceInQuickUse </SPAN>and the name of the reserving application will be output with <I>app_in_use_name</I>.</LI>
<LI>If access type = Release:<BR>
- if the device is reserved by the host application, the device will be released, the call&#39;s return value will be <SPAN CLASS="Courier_New_Inline">AS_StorageError_None </SPAN>and AuthorScript will not fill in the AS_String object referenced with <I>app_in_use_name</I>.<BR>
- if the device is reserved by another application, the device will not be released, the call&#39;s return value will be <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceInUse </SPAN>or <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceInQuickUse</SPAN>, and the name of the reserving application will be output with <I>app_in_use_name.</I> </LI></UL>
<P CLASS="IndentSerif"><B><FONT COLOR="ff0000">!</FONT> NOTE</B>: This function should always be used to reserve the target device prior to calling the volume functions (AS_Volume_<I>Xxx</I>) and file functions (AS_File_<I>Xxx</I>) covered in <A HREF="AD_Guide_7.htm">Chapter 7</A>, as well as the following device functions covered in this chapter:<BR>
- AS_StorageDevice_GetMediaProperty<BR>
- AS_StorageDevice_GetState<BR>
- AS_StorageDevice_SetMediaProperty<BR>
- AS_StorageDevice_EraseMedia<BR>
- AS_StorageDevice_TrayControl<BR>
- AS_StorageDevice_OpenVolume</P>

<P CLASS="SubHead_Sans11">Syntax</P>
<P CLASS="Code">
AS_StorageError AS_API AS_StorageDevice_ExclusiveAccess(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::ExclusiveAccess_Type access_type,<BR>
&nbsp;&nbsp;const AS_String & access_name,<BR>
&nbsp;&nbsp;AS_String & app_in_use_name<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device for which to activate, deactivate, or query exclusive access.</P>

<P CLASS="Code_Ital">access_type [IN]</P>
<P CLASS="Def_Field">An <A HREF="AD_Guide_5.htm#Exclusive access">Exclusive access</A> enum (AS_StorageDevice::ExclusiveAccess_Type) specifying the operation to be performed by the call.</P>

<P CLASS="Code_Ital">access_name [IN]</P>
<P CLASS="Def_Field">A constant reference to an <A HREF="AD_Guide_5.htm#AS_String">AS_String</A> struct specifying the name of the host application.</P>

<P CLASS="Code_Ital">app_in_use_name [OUT]</P>
<P CLASS="Def_Field">A reference to the <A HREF="AD_Guide_5.htm#AS_String">AS_String</A> struct to be filled in with the name of the application, if any, using the drive.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceInUse</SPAN>: the drive is already in use.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceInQuickUse</SPAN>: the drive is already in quick use.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: invalid drive handle or invalid access_type flag.</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Device and Media Profile">6.2 &nbsp;Device and Media Profile</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section covers the following calls:</P>

<P CLASS="LinksList"><A HREF="#AS_StorageDevice_GetState">AS_StorageDevice_GetState</A>, <A HREF="#AS_StorageDevice_GetDeviceProperty">AS_StorageDevice_GetDeviceProperty</A>, <A HREF="#AS_StorageDevice_GetMediaProperty">AS_StorageDevice_GetMediaProperty</A>, <A HREF="#AS_StorageDevice_SetMediaProperty">AS_StorageDevice_SetMediaProperty</A>, <A HREF="#AS_StorageDevice_GetTrackProperty">AS_StorageDevice_GetTrackProperty</A>, <A HREF="#AS_StorageDevice_SetTrackProperty">AS_StorageDevice_SetTrackProperty</A></P>
<P CLASS="IndentSerif">These calls are used to get information about the status and capabilities of a device and the media it contains.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_GetState">AS_StorageDevice_GetState</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device and Media Profile">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_GetState accesses the specified device and outputs the device state (not ready, ready, or becoming ready) with the parameter <I>state</I>.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> The call will access the media in the specified drive.<BR>
<B>&#187;</B> The device should be reserved (see <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using this function.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_GetState(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::DeviceState & state<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device.</P>

<P CLASS="Code_Ital">state [OUT]</P>
<P CLASS="Def_Field">A reference to the object that is to be filled in with a <A HREF="AD_Guide_5.htm#Device state">Device state</A> value (enum AS_StorageDevice::DeviceState) indicating the state of the device.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: device handle is invalid.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_GetDeviceProperty">AS_StorageDevice_GetDeviceProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device and Media Profile">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_GetDeviceProperty retrieves the value of a property of the specified device. The type of property (device type or supported media types) is specified with the parameter <I>device_property</I>. The buffer to which the property should be written is specified with <I>property_buffer</I>, the size of which is specified with <I>buffer_size</I>. When the call completes successfully, the actual size of the property&#39;s available data is output with <I>ret_data_size</I>. The remaining parameters are currently reserved for future use.<BR>
<BR>
<B>NOTE</B>: To query only the size of the property data, specify <I>property_buffer</I> as <SPAN CLASS="Courier_New_Inline">NULL </SPAN>and <I>buffer_size</I> as 0; <I>ret_data_size</I> will output the number of available bytes. </P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_GetDeviceProperty(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::DevProp_Type device_property,<BR>
&nbsp;&nbsp;UInt32 buffer_size,<BR>
&nbsp;&nbsp;Void * property_buffer,<BR>
&nbsp;&nbsp;UInt32 * ret_data_size,<BR>
&nbsp;&nbsp;UInt32 property_index = 0,<BR>
&nbsp;&nbsp;UInt32 ext_buffer_size = 0,<BR>
&nbsp;&nbsp;Void * ext_property_buffer = 0,<BR>
&nbsp;&nbsp;UInt32 * ext_ret_data_size = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device.</P>

<P CLASS="Code_Ital">device_property [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Device property type">Device property type</A> (enum AS_StorageDevice::DevProp_Type) specifying the device property whose value is to be retrieved. </P>

<P CLASS="Code_Ital">buffer_size [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size in bytes of the buffer to which the property data is to be written.</P>

<P CLASS="Code_Ital">property_buffer [OUT]</P>
<P CLASS="Def_Field">A pointer to the buffer that is to be filled in with the data retrieved for the specified property.</P>

<P CLASS="Code_Ital">ret_data_size [OUT]</P>
<P CLASS="Def_Field">A pointer to a UInt32 that is to be filled in with the size in bytes of the property data available for the specified property.</P>

<P CLASS="Code_Ital">property_index [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_buffer_size [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_property_buffer [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_ret_data_size [OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the device reference is invalid or the buffer is smaller than the return value.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceError</SPAN>: the device reported an error.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_GetMediaProperty">AS_StorageDevice_GetMediaProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device and Media Profile">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_GetMediaProperty retrieves the current value for a property of the media in the specified device. The type of property (number of layers, media type, state, bytes used, or bytes free) is specified with the parameter <I>media_property</I>. The buffer to which the property should be written is specified with <I>property_buffer</I>, the size of which is specified with <I>buffer_size</I>. When the call completes successfully, the actual size of the property&#39;s available data is output with <I>ret_data_size</I>. The remaining parameters are currently reserved for future use.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> To query only the size of the property data, specify <I>property_buffer</I> as <SPAN CLASS="Courier_New_Inline">NULL </SPAN>and <I>buffer_size</I> as 0; <I>ret_data_size</I> will output the number of available bytes.<BR>
<B>&#187;</B> The device should be reserved (see <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using this function.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_GetMediaProperty(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::MediaProp_Type media_property,<BR>
&nbsp;&nbsp;UInt32 buffer_size,<BR>
&nbsp;&nbsp;Void * property_buffer,<BR>
&nbsp;&nbsp;UInt32 * ret_data_size,<BR>
&nbsp;&nbsp;UInt32 property_index = 0,<BR>
&nbsp;&nbsp;UInt32 ext_buffer_size = 0,<BR>
&nbsp;&nbsp;Void * ext_property_buffer = 0,<BR>
&nbsp;&nbsp;UInt32 * ext_ret_data_size = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device in which the media exists.</P>

<P CLASS="Code_Ital">media_property [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Media property type">Media property type</A> (enum AS_StorageDevice::MediaProp_Type) specifying the media property whose value is to be retrieved.</P>

<P CLASS="Code_Ital">buffer_size [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size in bytes of the buffer to which the property data is to be written.</P>

<P CLASS="Code_Ital">property_buffer [OUT]</P>
<P CLASS="Def_Field">A pointer to the buffer that is to be filled in with the data retrieved for the specified property.</P>

<P CLASS="Code_Ital">ret_data_size [OUT]</P>
<P CLASS="Def_Field">A pointer to a UInt32 that is to be filled in with the size in bytes of the property data available for the specified property.</P>

<P CLASS="Code_Ital">property_index [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_buffer_size [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_property_buffer [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_ret_data_size [OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the device reference is invalid or the buffer is smaller than the return value.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceError</SPAN>: the device reported an error.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceNotReady</SPAN>: the device reports no media.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_SetMediaProperty">AS_StorageDevice_SetMediaProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device and Media Profile">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_SetMediaProperty sets the value of a property of the media in the specified device. The property to set is specified with the parameter <I>media_property</I>. The buffer from which the new value of the property should be written is specified with <I>property_buffer</I>, and the size of this buffer is specified with <I>buffer_size</I>.<BR>
<BR>
There are currently two properties that may be set with this call, each of which corresponds to one of two methods that may be used to define the data rate for writing to the media:</P>
<UL CLASS="IndentSerif_List"><LI><B><A ID="Data rates">Data rates</A></B> &#151; The property <SPAN CLASS="Courier_New_Inline">MedProp_CurWrite_DataRates </SPAN>is used to give the actual data rate for writing to the media, which is expressed in KB per second (e.g. 5440 for 4x DVD media).</LI>
<LI><B><A ID="Hundredths of X">Hundredths of X</A></B> &#151; The property <SPAN CLASS="Courier_New_Inline">MedProp_CurWrite_Hundredth_X </SPAN>is used to give the write speed for the media expressed as hundredths of X, where X is the nominal single-speed data rate for the media type (e.g. 400 for 4x media, which would result in a data rate of 5440 KBps for DVD media or 704 KBps for CD media).</LI></UL>
<P CLASS="IndentSerif">Either of these two methods of expressing the write speed may be used; if the values of the two properties would each result in different speeds the value of the more recently set property takes precedence.<BR>
<BR>
The recommended procedure for setting either property is to first retrieve a list of possible values for the specified drive&#47;media combination by calling <A HREF="#AS_StorageDevice_GetMediaProperty">AS_StorageDevice_GetMediaProperty</A> for the property <SPAN CLASS="Courier_New_Inline">MedProp_WriteList_DataRates </SPAN>or <SPAN CLASS="Courier_New_Inline">MedProp_WriteList_Hundredth_X</SPAN>. The corresponding write speed property may then be set with this function to one of the values in the list.<BR>
<BR>
Unless otherwise set with this call, the value of each property will default to the highest write speed available for the specified drive&#47;media combination. To reset either property to its default state, specify its value as <SPAN CLASS="Courier_New_Inline">Oxffffffff</SPAN>.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> An error will result unless the property specified with <I>media_property</I> is either <SPAN CLASS="Courier_New_Inline">MedProp_CurWrite_DataRates </SPAN>or <SPAN CLASS="Courier_New_Inline">MedProp_CurWrite_Hundredth_X</SPAN>. <BR>
<B>&#187;</B> The device should be reserved (see <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using this function.<BR>
<B>&#187;</B> Additional parameters are reserved for future use as noted.</P>

<P CLASS="SubHead_Sans11">Syntax</P>
<P CLASS="Code">
AS_StorageError AS_API AS_StorageDevice_SetMediaProperty(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::MediaProp_Type media_property,<BR>
&nbsp;&nbsp;UInt32 buffer_size,<BR>
&nbsp;&nbsp;void* property_buffer,<BR>
&nbsp;&nbsp;UInt32 property_index = 0,<BR>
&nbsp;&nbsp;UInt32 ext_buffer_size = 0,<BR>
&nbsp;&nbsp;void* ext_property_buffer = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="SubHead_SubSans11">Input</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device in which the media exists.</P>

<P CLASS="Code_Ital">media_property [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Media property type">Media property type</A> (enum AS_StorageDevice::MediaProp_Type) specifying the media property whose value is to be set.</P>

<P CLASS="Code_Ital">buffer_size [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size in bytes of the buffer in which the new property data exists.</P>

<P CLASS="Code_Ital">property_buffer [IN]</P>
<P CLASS="Def_Field">A pointer to the buffer in which the new property data exists.</P>

<P CLASS="Code_Ital">property_index [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_buffer_size [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_property_buffer [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the device reference is invalid or the buffer is smaller than the return value.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceError</SPAN>: the device reported an error.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceNotReady</SPAN>: the device reports no media.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_GetTrackProperty">AS_StorageDevice_GetTrackProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device and Media Profile">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice_h.doc</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_GetTrackProperty retrieves the current value of a property of a track on the media in the specified device. The number of the track (1 to the number of tracks in the volume) is specified with the parameter <I>trackNum</I>. The type of property (e.g. length, start address, preGap, record mode, etc.) is specified with the parameter <I>track_property</I>. The buffer to which the property should be written is specified with <I>property_buffer</I>, the size of which is specified with <I>buffer_size</I>. When the call completes successfully, the actual size of the property&#39;s available data is output with <I>ret_data_size</I>. The remaining parameters are currently reserved for future use.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> To query only the size of the property data, specify property_buffer as NULL and buffer_size as 0; ret_data_size will output the number of available bytes.<BR>
<B>&#187;</B> The maximum valid value for <I>trackNum</I> may be determined by calling <A HREF="#AS_StorageDevice_GetMediaProperty">AS_StorageDevice_GetMediaProperty</A> with <I>media_property</I> specified as <SPAN CLASS="Courier_New_Inline">MedProp_Num_Tracks</SPAN>.</P>

<P CLASS="SubHead_Sans11">Syntax</P>
<P CLASS="Code">
AS_StorageError AS_API AS_StorageDevice_GetTrackProperty(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;UInt32 trackNum,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::TrackProp_Type track_property,<BR>
&nbsp;&nbsp;UInt32 buffer_size,<BR>
&nbsp;&nbsp;void * property_buffer,<BR>
&nbsp;&nbsp;UInt32* ret_data_size,<BR>
&nbsp;&nbsp;UInt32 property_index = 0,<BR>
&nbsp;&nbsp;UInt32 ext_buffer_size = 0,<BR>
&nbsp;&nbsp;void* ext_property_buffer = 0,<BR>
&nbsp;&nbsp;UInt32* ext_ret_data_size = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device.</P>

<P CLASS="Code_Ital">trackNum [IN]</P>
<P CLASS="Def_Field">A Uint32 specifying the number of the track.</P>

<P CLASS="Code_Ital">track_property [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Track property type">Track property type</A> (enum AS_StorageDevice::TrackProp_Type) specifying the property whose value is to be retrieved.</P>

<P CLASS="Code_Ital">buffer_size [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size in bytes of the buffer to which the property data is to be written.</P>

<P CLASS="Code_Ital">property_buffer [OUT]</P>
<P CLASS="Def_Field">A pointer to the buffer that is to be filled in with the data retrieved for the specified property.</P>

<P CLASS="Code_Ital">ret_data_size [OUT]</P>
<P CLASS="Def_Field">A pointer to a UInt32 that is to be filled in with the size in bytes of the property data available for the specified property.</P>

<P CLASS="Code_Ital">property_index [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_buffer_size [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_property_buffer [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_ret_data_size [OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the device reference is invalid.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_SetTrackProperty">AS_StorageDevice_SetTrackProperty</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device and Media Profile">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice_h.doc</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_SetTrackProperty sets the value of a property of a track on the media in the specified device. The number of the track (1 to the number of tracks in the volume) is specified with the parameter <I>trackNum</I>. The type of property (e.g. length, start address, preGap, record mode, etc.) is specified with the parameter <I>track_property</I>. The buffer to which the property should be written is specified with <I>property_buffer</I>, the size of which is specified with <I>buffer_size</I>. The remaining parameters are currently reserved for future use.</P>

<P CLASS="SubHead_Sans11">Syntax</P>
<P CLASS="Code">
AS_StorageError AS_API AS_StorageDevice_SetTrackProperty(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;UInt32 trackNum,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::TrackProp_Type track_property,<BR>
&nbsp;&nbsp;UInt32 buffer_size,<BR>
&nbsp;&nbsp;void * property_buffer,<BR>
&nbsp;&nbsp;UInt32 property_index = 0,<BR>
&nbsp;&nbsp;UInt32 ext_buffer_size = 0,<BR>
&nbsp;&nbsp;void * ext_property_buffer = 0<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the AS_StorageDevice struct specifying the device.</P>

<P CLASS="Code_Ital">trackNum [IN]</P>
<P CLASS="Def_Field">A Uint32 specifying the number of the track.</P>

<P CLASS="Code_Ital">track_property [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Track property type">Track property type</A> (enum AS_StorageDevice::TrackProp_Type) specifying the property whose value is to be set.</P>

<P CLASS="Code_Ital">buffer_size [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the size in bytes of the buffer in which the new property data exists.</P>

<P CLASS="Code_Ital">property_buffer [IN]</P>
<P CLASS="Def_Field">A pointer to the buffer that is to be filled in with the data retrieved for the specified property.</P>

<P CLASS="Code_Ital">property_index [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_buffer_size [IN]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="Code_Ital">ext_property_buffer [IN&#47;OUT]</P>
<P CLASS="Def_Field">Optional: Reserved for future use (specify as 0).</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: the device reference is invalid or the buffer is smaller than the return value.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceError</SPAN>: the device reported an error.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceNotReady</SPAN>: the device reports no media.</P>

<HR SIZE=2 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading2"><A ID="Device Commands">6.3 &nbsp;Device Commands</A></TD><TD CLASS="IndentSansVisited" WIDTH=50>go: &nbsp;<A HRef="#chapter">top</A></TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">This section covers the following calls:</P>

<P CLASS="LinksList"><A HREF="#AS_StorageDevice_TrayControl">AS_StorageDevice_TrayControl</A>, <A HREF="#AS_StorageDevice_EraseMedia">AS_StorageDevice_EraseMedia</A></P>
<P CLASS="IndentSerif">These calls are used to send instructions to the currently selected device (to select a drive, see <A HREF="#Device call sequence"><SPAN CLASS="Arial_Inline"><B>Device call sequence</B></SPAN></A>).</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_TrayControl">AS_StorageDevice_TrayControl</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device Commands">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_TrayControl is used to control operation (lock, unlock, open, close, etc.) of the media tray of the specified device.<BR>
<BR>
<B>NOTES</B>:<BR>
<B>&#187;</B> An error will result if the device is currently in use. <BR>
<B>&#187;</B> The device should be reserved (see <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using this function.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_TrayControl(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::TrayControls tray_control_type<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device.</P>

<P CLASS="Code_Ital">tray_control_type [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Tray controls">Tray controls</A> value (enum AS_StorageDevice::TrayControls) specifying the desired tray control operation.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: invalid device reference.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceError</SPAN>: the device reported an error.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_Copy ">AS_StorageDevice_Copy </A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device Commands">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_Copy copies data from a source drive to one or more destination drives. The source drive is specified with the parameter <I>srcDevice</I>. The number of destination drives(s) is specified with <I>NumDevices</I>, while the device reference for each drive is specified in the array passed with <I>DeviceList</I>.<BR>
<BR>
The copy operation may involve the entire contents of the media in the source drive, or only the contents of the track specified with the optional parameter <I>trackNum</I>. The type of copy operation is determined by the copy flag specified with <I>flag</I>, while the format of the destination files (same format for all destinations), is specified with <I>format</I>. <BR>
<BR>
A callback with which the AuthorScript engine will report on the progress of the copying is specified with <I>callback</I>. The parameter <I>userData</I> allows the host application to specify a pointer to a memory location that will be passed back whenever AuthorScript calls the callback.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_Copy (<BR>
&nbsp;&nbsp;const AS_StorageDevice & srcDevice,<BR>
&nbsp;&nbsp;AS_StorageDevice::FileFormatType format,<BR>
&nbsp;&nbsp;AS_StorageDevice::CopyFlags flag,<BR>
&nbsp;&nbsp;UInt32 trackNum,<BR>
&nbsp;&nbsp;UInt32 NumDevices,<BR>
&nbsp;&nbsp;const AS_StorageDevice * DeviceList,<BR>
&nbsp;&nbsp;AS_StorageDevice::InfoCallback callback,<BR>
&nbsp;&nbsp;void * userData<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">srcDevice [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the source device.</P>

<P CLASS="Code_Ital">format [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#File format type">File format type</A> constant specifying the format type for the destination file(s).</P>

<P CLASS="Code_Ital">flag [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#CopyFlags">CopyFlags</A> constant specifying the type of the copy operation.</P>

<P CLASS="Code_Ital">trackNum [IN]</P>
<P CLASS="Def_Field">Optional: A UInt32 specifying an individual track to copy from the source to the destination.</P>

<P CLASS="Code_Ital">NumDevices [IN]</P>
<P CLASS="Def_Field">A UInt32 specifying the number of  destination devices in <I>DeviceList</I>.</P>

<P CLASS="Code_Ital">DeviceList [IN]</P>
<P CLASS="Def_Field">A constant pointer to an array containing an <A HREF="AD_Guide_5.htm#AS_Storage">AS_Storage</A> struct for each destination device.</P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Device information callback">Device information callback</A> (AS_StorageDevice::InfoCallback) used to report progress information.</P>

<P CLASS="Code_Ital">userData [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError</P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: invalid device reference.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceError</SPAN>: the device reported an error.</P>

<HR noshade SIZE=1 WIDTH="93%"><TABLE WIDTH="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="Heading4"><A ID="AS_StorageDevice_EraseMedia">AS_StorageDevice_EraseMedia</A></TD><TD CLASS="IndentSansVisited" WIDTH=110>go: &nbsp;<A HRef="#chapter">top</A> &nbsp; &nbsp;| &nbsp; &nbsp;<A HRef="#Device Commands">section</A></TD></TR></TBODY></TABLE>
<TABLE width="93%" ALIGN=center BORDER=0><TBODY><TR><TD CLASS="IndentSans" HEIGHT=21>Header File: AS_StorageDevice.h</TD></TR></TBODY></TABLE>
<P CLASS="IndentSerif">AS_StorageDevice_EraseMedia erases the media, if any, in the specified device. The type of erase operation to perform (quick or long) is specified with the parameter <I>erase_type</I>. A callback with which the AuthorScript engine will report on the progress of the erasure is specified with <I>callback</I>. The parameter <I>userdata</I> allows the host application to specify a pointer to a memory location that will be passed back whenever AuthorScript calls the callback.<BR>
<BR>
<B>NOTES:<BR>
&#187;</B> The device state must be ready (see <A HREF="#AS_StorageDevice_GetState">AS_StorageDevice_GetState</A>).<BR>
<B>&#187;</B> An error will result if the device is currently in use by AuthorScript AD. <BR>
<B>&#187;</B> The device should be reserved (see <A HREF="#AS_StorageDevice_ExclusiveAccess">AS_StorageDevice_ExclusiveAccess</A>) before using this function.</P>

<P CLASS="SubHead_Sans11">Syntax</P>

<P CLASS="Code">AS_StorageError AS_API AS_StorageDevice_EraseMedia(<BR>
&nbsp;&nbsp;const AS_StorageDevice & device,<BR>
&nbsp;&nbsp;enum AS_StorageDevice::Erase_Type erase_type,<BR>
&nbsp;&nbsp;AS_StorageDevice::InfoCallback callback,<BR>
&nbsp;&nbsp;void * userdata<BR>
);</P>

<P CLASS="SubHead_Sans11">Parameters</P>

<P CLASS="Code_Ital">device [IN]</P>
<P CLASS="Def_Field">A constant reference to the <A HREF="AD_Guide_5.htm#AS_StorageDevice">AS_StorageDevice</A> struct specifying the device.</P>

<P CLASS="Code_Ital">erase_type [IN]</P>
<P CLASS="Def_Field">An <A HREF="AD_Guide_5.htm#Erase type">Erase type</A> value (enum AS_StorageDevice::Erase_Type) specifying the type of erase operation to perform. </P>

<P CLASS="Code_Ital">callback [IN]</P>
<P CLASS="Def_Field">A <A HREF="AD_Guide_5.htm#Device information callback">Device information callback</A> (AS_StorageDevice::InfoCallback) used to report progress information.</P>

<P CLASS="Code_Ital">userdata [IN]</P>
<P CLASS="Def_Field">A pointer to optional user-defined data that the AuthorScript engine will pass back to the host application when calling the callback.</P>

<P CLASS="SubHead_Sans11">Return Value</P>

<P CLASS="Code_Ital">AS_StorageError </P>
<P CLASS="Def_Field">An error constant of type <A HREF="AD_Guide_5.htm#AS_StorageError">AS_StorageError</A> indicating the outcome of the call. For this function, possible values include:<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_None</SPAN>: call completed successfully.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_InvalidParameter</SPAN>: invalid device reference.<BR>
- <SPAN CLASS="Courier_New_Inline">AS_StorageError_DeviceError</SPAN>: the device reported an error.</P>

<P CLASS="IndentSans"><A HRef= "#chapter">Top</A></P>
</BODY>
</HTML>
